!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2000 - 2014  CP2K developers group                          !
!-----------------------------------------------------------------------------!

! *****************************************************************************
!> \brief Contains methods used in the context of density fitting
!> \par History
!>      04.2008 created [Manuel Guidon]
!> \author Manuel Guidon
! *****************************************************************************
MODULE admm_methods
  USE admm_types,                      ONLY: admm_type,&
                                             mcweeny_history_type
  USE atomic_kind_types,               ONLY: atomic_kind_type
  USE cp_dbcsr_cp2k_link,              ONLY: cp_dbcsr_alloc_block_from_nbl
  USE cp_dbcsr_interface,              ONLY: &
       cp_dbcsr_add, cp_dbcsr_col_block_sizes, cp_dbcsr_copy, &
       cp_dbcsr_create, cp_dbcsr_deallocate_matrix, cp_dbcsr_distribution, &
       cp_dbcsr_frobenius_norm, cp_dbcsr_get_block_p, cp_dbcsr_get_data_size, &
       cp_dbcsr_get_data_type, cp_dbcsr_get_num_blocks, cp_dbcsr_init, &
       cp_dbcsr_iterator, cp_dbcsr_iterator_blocks_left, &
       cp_dbcsr_iterator_next_block, cp_dbcsr_iterator_start, &
       cp_dbcsr_iterator_stop, cp_dbcsr_multiply, cp_dbcsr_p_type, &
       cp_dbcsr_release, cp_dbcsr_row_block_sizes, cp_dbcsr_scale, &
       cp_dbcsr_set, cp_dbcsr_type, dbcsr_type_no_symmetry, &
       dbcsr_type_symmetric
  USE cp_dbcsr_operations,             ONLY: copy_dbcsr_to_fm,&
                                             copy_fm_to_dbcsr,&
                                             cp_dbcsr_plus_fm_fm_t
  USE cp_dbcsr_output,                 ONLY: cp_dbcsr_write_sparse_matrix
  USE cp_fm_basic_linalg,              ONLY: cp_fm_column_scale,&
                                             cp_fm_scale,&
                                             cp_fm_scale_and_add,&
                                             cp_fm_schur_product,&
                                             cp_fm_upper_to_full
  USE cp_fm_cholesky,                  ONLY: cp_fm_cholesky_decompose,&
                                             cp_fm_cholesky_invert,&
                                             cp_fm_cholesky_reduce,&
                                             cp_fm_cholesky_restore
  USE cp_fm_diag,                      ONLY: cp_fm_syevd
  USE cp_fm_types,                     ONLY: cp_fm_p_type,&
                                             cp_fm_set_all,&
                                             cp_fm_set_element,&
                                             cp_fm_to_fm,&
                                             cp_fm_type
  USE cp_gemm_interface,               ONLY: cp_gemm
  USE cp_output_handling,              ONLY: cp_p_file,&
                                             cp_print_key_finished_output,&
                                             cp_print_key_should_output,&
                                             cp_print_key_unit_nr
  USE cp_para_types,                   ONLY: cp_para_env_type
  USE input_constants,                 ONLY: &
       do_admm_purify_cauchy, do_admm_purify_cauchy_subspace, &
       do_admm_purify_mcweeny, do_admm_purify_mo_diag, &
       do_admm_purify_mo_no_diag, do_admm_purify_none, &
       do_hfx_potential_coulomb, do_hfx_potential_short, &
       do_hfx_potential_truncated, use_aux_fit_basis_set, use_orb_basis_set, &
       xc_funct_no_shortcut
  USE input_section_types,             ONLY: section_vals_duplicate,&
                                             section_vals_get_subs_vals,&
                                             section_vals_get_subs_vals2,&
                                             section_vals_remove_values,&
                                             section_vals_type,&
                                             section_vals_val_get,&
                                             section_vals_val_set
  USE kinds,                           ONLY: dp
  USE qs_environment_types,            ONLY: get_qs_env,&
                                             qs_environment_type
  USE qs_force_types,                  ONLY: add_qs_force,&
                                             qs_force_type
  USE qs_mo_types,                     ONLY: get_mo_set,&
                                             mo_set_p_type,&
                                             mo_set_type
  USE qs_overlap,                      ONLY: build_overlap_force
  USE timings,                         ONLY: timeset,&
                                             timestop
#include "./common/cp_common_uses.f90"

  IMPLICIT NONE
  PRIVATE

  PUBLIC :: admm_fit_mo_coeffs,&
            admm_merge_ks_matrix,&
            admm_merge_mo_derivs,&
            calc_aux_mo_derivs_none,&
            calc_mixed_overlap_force,&
            create_admm_xc_section,&
            admm_calculate_density_matrix

  CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'admm_methods'

  CONTAINS

! *****************************************************************************
!> \brief ...
!> \param admm_env ...
!> \param mo_set ...
!> \param density_matrix ...
!> \param density_matrix_aux ...
!> \param matrix_s_aux_fit ...
!> \param ispin ...
!> \param nspins ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE admm_calculate_density_matrix(admm_env,mo_set,density_matrix, density_matrix_aux,&
                                           matrix_s_aux_fit, ispin, nspins,error)
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(cp_dbcsr_type), POINTER             :: density_matrix, &
                                                density_matrix_aux, &
                                                matrix_s_aux_fit
    INTEGER                                  :: ispin, nspins
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: &
      routineN = 'admm_calculate_density_matrix', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle

    CALL timeset(routineN,handle)

    IF(admm_env%block_dm) THEN
       CALL blockify_density_matrix(admm_env, density_matrix, density_matrix_aux, ispin, nspins, error)
    ELSE
       CALL calculate_dm_mo_no_diag(admm_env, mo_set, density_matrix_aux, ispin, error)
    ENDIF

    IF(admm_env%purification_method == do_admm_purify_cauchy)&
        CALL purify_dm_cauchy(admm_env, mo_set, density_matrix_aux, ispin,&
                              blocked=admm_env%block_dm, error=error)

    IF(admm_env%purification_method == do_admm_purify_mcweeny)THEN
        IF(nspins==1) CALL cp_dbcsr_scale(density_matrix_aux,0.5_dp,error=error)
        CALL purify_dm_mcweeny(matrix_p=density_matrix_aux,&
                               matrix_s=matrix_s_aux_fit,&
                               history=admm_env%mcweeny_history(ispin)%p,&
                               threshold=1e-10_dp,& !TODO make it an input parameter
                               max_steps=100,& !TODO make it an input parameter
                               error=error)
       IF(nspins==1) CALL cp_dbcsr_scale(density_matrix_aux,2.0_dp,error=error)
    ENDIF

    CALL timestop(handle)

  END SUBROUTINE admm_calculate_density_matrix

! *****************************************************************************
!> \brief ...
!> \param ispin ...
!> \param admm_env ...
!> \param mo_set ...
!> \param mo_coeff ...
!> \param mo_coeff_aux_fit ...
!> \param mo_derivs ...
!> \param mo_derivs_aux_fit ...
!> \param matrix_ks_aux_fit ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE admm_merge_mo_derivs(ispin, admm_env, mo_set, mo_coeff, mo_coeff_aux_fit, mo_derivs, &
                                  mo_derivs_aux_fit, matrix_ks_aux_fit, error)
    INTEGER, INTENT(IN)                      :: ispin
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(cp_fm_type), POINTER                :: mo_coeff, mo_coeff_aux_fit
    TYPE(cp_fm_p_type), DIMENSION(:), &
      POINTER                                :: mo_derivs, mo_derivs_aux_fit
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_ks_aux_fit
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'admm_merge_mo_derivs', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle

    CALL timeset(routineN,handle)

    SELECT CASE(admm_env%purification_method)
      CASE(do_admm_purify_mo_diag)
        CALL merge_mo_derivs_diag(ispin, admm_env, mo_set, mo_coeff, mo_coeff_aux_fit,&
                                  mo_derivs,mo_derivs_aux_fit, matrix_ks_aux_fit,&
                                  error)
      CASE(do_admm_purify_mo_no_diag)
        CALL merge_mo_derivs_no_diag(ispin, admm_env, mo_set, mo_coeff, mo_coeff_aux_fit,&
                                     mo_derivs,mo_derivs_aux_fit, matrix_ks_aux_fit,&
                                     error)
      CASE(do_admm_purify_none, do_admm_purify_cauchy,do_admm_purify_cauchy_subspace)
       !do nothing
    END SELECT

    CALL timestop(handle)

  END SUBROUTINE admm_merge_mo_derivs

! *****************************************************************************
!> \brief ...
!> \param ispin ...
!> \param admm_env ...
!> \param mo_set ...
!> \param mo_coeff ...
!> \param mo_coeff_aux_fit ...
!> \param matrix_ks ...
!> \param matrix_ks_aux_fit ...
!> \param matrix_s ...
!> \param matrix_s_aux_fit ...
!> \param matrix_s_mixed ...
!> \param matrix_p_aux_fit ...
!> \param matrix_p ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE admm_merge_ks_matrix(ispin, admm_env, mo_set, mo_coeff, mo_coeff_aux_fit, &
                                             matrix_ks, matrix_ks_aux_fit, matrix_s,&
                                             matrix_s_aux_fit, matrix_s_mixed,&
                                             matrix_p_aux_fit, matrix_p, error)
    INTEGER, INTENT(IN)                      :: ispin
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(cp_fm_type), POINTER                :: mo_coeff, mo_coeff_aux_fit
    TYPE(cp_dbcsr_p_type), DIMENSION(:), POINTER :: matrix_ks, &
      matrix_ks_aux_fit, matrix_s, matrix_s_aux_fit, matrix_s_mixed, &
      matrix_p_aux_fit, matrix_p
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'admm_merge_ks_matrix', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle
    TYPE(cp_dbcsr_type)                      :: matrix_A

    CALL timeset(routineN,handle)

    SELECT CASE(admm_env%purification_method)
      CASE(do_admm_purify_cauchy)
        CALL merge_ks_matrix_cauchy(ispin, admm_env, mo_set, mo_coeff,&
                                    mo_coeff_aux_fit, matrix_ks, matrix_ks_aux_fit, &
                                    matrix_s, matrix_p_aux_fit, matrix_p, blocked=admm_env%block_dm, error=error)
      CASE(do_admm_purify_cauchy_subspace)
        CALL merge_ks_matrix_cauchy_subspace(ispin, admm_env, mo_set, mo_coeff,&
                                             mo_coeff_aux_fit, matrix_ks, matrix_ks_aux_fit, &
                                             matrix_s, matrix_p_aux_fit, error)
      CASE(do_admm_purify_none)
        CALL merge_ks_matrix_none(ispin, admm_env, mo_set, mo_coeff,&
                                  mo_coeff_aux_fit, matrix_ks, matrix_ks_aux_fit, &
                                  matrix_s, matrix_p_aux_fit, blocked=admm_env%block_dm, error=error)

      CASE(do_admm_purify_mcweeny)
        ! TODO conversion fm->dbcsr really needed?
        CALL cp_dbcsr_init(matrix_A, error=error)
        CALL cp_dbcsr_create(matrix_A, template=matrix_s_mixed(1)%matrix,&
                             name="A", matrix_type="N", error=error)
        CALL copy_fm_to_dbcsr(admm_env%A, matrix_A, error=error)
        CALL merge_ks_matrix_mcweeny(matrix_ks(ispin)%matrix,&
                                     matrix_ks_aux_fit(ispin)%matrix,&
                                     matrix_s_aux_fit(1)%matrix,&
                                     matrix_A,&
                                     admm_env%mcweeny_history(ispin)%p,&
                                     threshold=1e-10_dp,& !TODO make it an input parameter
                                     error=error)
        CALL cp_dbcsr_release(matrix_A, error=error)

      CASE(do_admm_purify_mo_diag,do_admm_purify_mo_no_diag)
        !do nothing
    END SELECT

    CALL timestop(handle)

  END SUBROUTINE admm_merge_ks_matrix


! *****************************************************************************
!> \brief ...
!> \param qs_env ...
!> \param admm_env ...
!> \param para_env ...
!> \param matrix_s_aux_fit ...
!> \param matrix_s_mixed ...
!> \param mos ...
!> \param mos_aux_fit ...
!> \param geometry_did_change ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE admm_fit_mo_coeffs(qs_env, admm_env, para_env, matrix_s_aux_fit, matrix_s_mixed, &
                                mos, mos_aux_fit, geometry_did_change, error)

    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_s_aux_fit, &
                                                matrix_s_mixed
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos, mos_aux_fit
    LOGICAL, INTENT(IN)                      :: geometry_did_change
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'admm_fit_mo_coeffs', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle

    CALL timeset(routineN,handle)

    CALL fit_mo_coeffs(qs_env, admm_env, para_env, matrix_s_aux_fit, matrix_s_mixed, &
                                 mos, mos_aux_fit, geometry_did_change,&
                                 blocked=admm_env%block_fit, error=error)

    SELECT CASE(admm_env%purification_method)
       CASE(do_admm_purify_cauchy_subspace, do_admm_purify_mo_no_diag)
         CALL purify_mo_cholesky(qs_env, admm_env, para_env, matrix_s_aux_fit, matrix_s_mixed, &
                                 mos, mos_aux_fit, error)

       CASE(do_admm_purify_mo_diag)
         CALL purify_mo_diag(qs_env, admm_env, para_env, matrix_s_aux_fit, matrix_s_mixed, &
                             mos, mos_aux_fit, error)
       CASE DEFAULT
         CALL purify_mo_none(qs_env, admm_env, para_env, matrix_s_aux_fit, matrix_s_mixed, &
                             mos, mos_aux_fit, error)
    END SELECT

    CALL timestop(handle)

  END SUBROUTINE admm_fit_mo_coeffs

! *****************************************************************************
!> \brief Calculates the MO coefficients for the auxiliary fitting basis set
!>        by minimizing int (psi_i - psi_aux_i)^2 using Lagrangian Multipliers
!>
!> \param qs_env ...
!> \param admm_env The ADMM env
!> \param para_env The parallel env
!> \param matrix_s_aux_fit the overlap matrix of the auxiliary fitting basis set
!> \param matrix_s_mixed the mixed overlap matrix of the auxiliary fitting basis
!>        set and the orbital basis set
!> \param mos the MO's of the orbital basis set
!> \param mos_aux_fit the MO's of the auxiliary fitting basis set
!> \param error ...
!> \par History
!>      05.2008 created [Manuel Guidon]
!> \author Manuel Guidon
! *****************************************************************************
  SUBROUTINE purify_mo_cholesky(qs_env, admm_env, para_env, matrix_s_aux_fit, matrix_s_mixed, &
                                mos, mos_aux_fit, error)

    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_s_aux_fit, &
                                                matrix_s_mixed
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos, mos_aux_fit
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'purify_mo_cholesky', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, ispin, nao_aux_fit, &
                                                nao_orb, nmo, nspins
    TYPE(cp_fm_type), POINTER                :: mo_coeff, mo_coeff_aux_fit

    CALL timeset(routineN,handle)

    nao_aux_fit = admm_env%nao_aux_fit
    nao_orb = admm_env%nao_orb
    nspins = SIZE(mos)

    ! *** Calculate the mo_coeffs for the fitting basis
    DO ispin=1,nspins
      nmo = admm_env%nmo(ispin)
      IF( nmo == 0 ) CYCLE
      !! Lambda = C^(T)*B*C
      CALL get_mo_set(mos(ispin)%mo_set,mo_coeff=mo_coeff)
      CALL get_mo_set(mos_aux_fit(ispin)%mo_set,mo_coeff=mo_coeff_aux_fit)
      CALL cp_gemm('N','N',nao_orb,nmo,nao_orb,&
                      1.0_dp,admm_env%B,mo_coeff,0.0_dp,&
                      admm_env%work_orb_nmo(ispin)%matrix,error)
      CALL cp_gemm('T','N',nmo,nmo,nao_orb,&
                      1.0_dp,mo_coeff,admm_env%work_orb_nmo(ispin)%matrix,0.0_dp,&
                      admm_env%lambda(ispin)%matrix,error)
      CALL cp_fm_to_fm(admm_env%lambda(ispin)%matrix, admm_env%work_nmo_nmo1(ispin)%matrix, error=error)



      CALL cp_fm_cholesky_decompose(admm_env%work_nmo_nmo1(ispin)%matrix,error=error)
      CALL cp_fm_cholesky_invert(admm_env%work_nmo_nmo1(ispin)%matrix,error=error)
      !! Symmetrize the guy
      CALL cp_fm_upper_to_full(admm_env%work_nmo_nmo1(ispin)%matrix,admm_env%lambda_inv(ispin)%matrix,error=error)
      CALL cp_fm_to_fm(admm_env%work_nmo_nmo1(ispin)%matrix,admm_env%lambda_inv(ispin)%matrix,error=error)


      !! ** C_hat = AC
      CALL cp_gemm('N', 'N',  nao_aux_fit, nmo, nao_orb,&
                      1.0_dp,admm_env%A,mo_coeff,0.0_dp,&
                      admm_env%C_hat(ispin)%matrix,error)
      CALL cp_fm_to_fm(admm_env%C_hat(ispin)%matrix, mo_coeff_aux_fit, error=error)

    END DO

    CALL timestop(handle)

  END SUBROUTINE purify_mo_cholesky

  
! *****************************************************************************
!> \brief Calculates the MO coefficients for the auxiliary fitting basis set
!>        by minimizing int (psi_i - psi_aux_i)^2 using Lagrangian Multipliers
!>
!> \param qs_env ...
!> \param admm_env The ADMM env
!> \param para_env The parallel env
!> \param matrix_s_aux_fit the overlap matrix of the auxiliary fitting basis set
!> \param matrix_s_mixed the mixed overlap matrix of the auxiliary fitting basis
!>        set and the orbital basis set
!> \param mos the MO's of the orbital basis set
!> \param mos_aux_fit the MO's of the auxiliary fitting basis set
!> \param error ...
!> \par History
!>      05.2008 created [Manuel Guidon]
!> \author Manuel Guidon
! *****************************************************************************
  SUBROUTINE purify_mo_diag(qs_env, admm_env, para_env, matrix_s_aux_fit, matrix_s_mixed, &
                                mos, mos_aux_fit, error)

    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_s_aux_fit, &
                                                matrix_s_mixed
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos, mos_aux_fit
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'purify_mo_diag', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, i, ispin, &
                                                nao_aux_fit, nao_orb, nmo, &
                                                nspins
    REAL(dp), ALLOCATABLE, DIMENSION(:)      :: eig_work
    TYPE(cp_fm_type), POINTER                :: mo_coeff, mo_coeff_aux_fit

    CALL timeset(routineN,handle)

    nao_aux_fit = admm_env%nao_aux_fit
    nao_orb = admm_env%nao_orb
    nspins = SIZE(mos)

    ! *** Calculate the mo_coeffs for the fitting basis
    DO ispin=1,nspins
      nmo = admm_env%nmo(ispin)
      IF( nmo == 0 ) CYCLE
      !! Lambda = C^(T)*B*C
      CALL get_mo_set(mos(ispin)%mo_set,mo_coeff=mo_coeff)
      CALL get_mo_set(mos_aux_fit(ispin)%mo_set,mo_coeff=mo_coeff_aux_fit)
      CALL cp_gemm('N','N',nao_orb,nmo,nao_orb,&
                      1.0_dp,admm_env%B,mo_coeff,0.0_dp,&
                      admm_env%work_orb_nmo(ispin)%matrix,error)
      CALL cp_gemm('T','N',nmo,nmo,nao_orb,&
                      1.0_dp,mo_coeff,admm_env%work_orb_nmo(ispin)%matrix,0.0_dp,&
                      admm_env%lambda(ispin)%matrix,error)
      CALL cp_fm_to_fm(admm_env%lambda(ispin)%matrix, admm_env%work_nmo_nmo1(ispin)%matrix, error=error)


      CALL cp_fm_syevd(admm_env%work_nmo_nmo1(ispin)%matrix,admm_env%R(ispin)%matrix,&
                       admm_env%eigvals_lambda(ispin)%eigvals%data,error=error)
      ALLOCATE(eig_work(nmo))
      DO i=1,nmo
        eig_work(i) = 1.0_dp/SQRT(admm_env%eigvals_lambda(ispin)%eigvals%data(i))
      END DO
      CALL cp_fm_to_fm(admm_env%R(ispin)%matrix, admm_env%work_nmo_nmo1(ispin)%matrix, error=error)
      CALL cp_fm_column_scale(admm_env%work_nmo_nmo1(ispin)%matrix,eig_work)
      CALL cp_gemm('N','T',nmo,nmo,nmo,&
                      1.0_dp,admm_env%work_nmo_nmo1(ispin)%matrix,admm_env%R(ispin)%matrix,0.0_dp,&
                      admm_env%lambda_inv_sqrt(ispin)%matrix,error)
      CALL cp_gemm('N','N',nao_orb,nmo,nmo,&
                      1.0_dp,mo_coeff,admm_env%lambda_inv_sqrt(ispin)%matrix,0.0_dp,&
                      admm_env%work_orb_nmo(ispin)%matrix,error)
      CALL cp_gemm('N','N',nao_aux_fit,nmo,nao_orb,&
                      1.0_dp,admm_env%A,admm_env%work_orb_nmo(ispin)%matrix, 0.0_dp,&
                      mo_coeff_aux_fit,error)

      CALL cp_fm_to_fm(mo_coeff_aux_fit, admm_env%C_hat(ispin)%matrix, error=error)
      CALL cp_fm_set_all(admm_env%lambda_inv(ispin)%matrix,0.0_dp,1.0_dp,error)
      DEALLOCATE(eig_work)
    END DO

    CALL timestop(handle)

  END SUBROUTINE purify_mo_diag

! *****************************************************************************
!> \brief ...
!> \param qs_env ...
!> \param admm_env ...
!> \param para_env ...
!> \param matrix_s_aux_fit ...
!> \param matrix_s_mixed ...
!> \param mos ...
!> \param mos_aux_fit ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE purify_mo_none(qs_env, admm_env, para_env, matrix_s_aux_fit, matrix_s_mixed, &
                                mos, mos_aux_fit, error)
    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_s_aux_fit, &
                                                matrix_s_mixed
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos, mos_aux_fit
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'purify_mo_none', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, ispin, nao_aux_fit, &
                                                nao_orb, nmo, nmo_mos, nspins
    REAL(KIND=dp), DIMENSION(:), POINTER     :: occ_num, occ_num_aux
    TYPE(cp_fm_type), POINTER                :: mo_coeff, mo_coeff_aux_fit

    CALL timeset(routineN,handle)

    nao_aux_fit = admm_env%nao_aux_fit
    nao_orb = admm_env%nao_orb
    nspins = SIZE(mos)

    DO ispin = 1,nspins
      nmo = admm_env%nmo(ispin)
      CALL get_mo_set(mos(ispin)%mo_set,mo_coeff=mo_coeff, occupation_numbers=occ_num,nmo=nmo_mos)
      CALL get_mo_set(mos_aux_fit(ispin)%mo_set,mo_coeff=mo_coeff_aux_fit,&
           occupation_numbers=occ_num_aux)

      CALL cp_gemm('N','N',nao_aux_fit,nmo,nao_orb,&
                      1.0_dp,admm_env%A,mo_coeff,0.0_dp,&
                      mo_coeff_aux_fit,error)
      CALL cp_fm_to_fm(mo_coeff_aux_fit, admm_env%C_hat(ispin)%matrix, error=error)

      occ_num_aux(1:nmo) = occ_num(1:nmo)
      ! XXXX should only be done first time XXXX
      CALL cp_fm_set_all(admm_env%lambda(ispin)%matrix,0.0_dp,1.0_dp,error)
      CALL cp_fm_set_all(admm_env%lambda_inv(ispin)%matrix,0.0_dp,1.0_dp,error)
      CALL cp_fm_set_all(admm_env%lambda_inv_sqrt(ispin)%matrix,0.0_dp,1.0_dp,error)
    END DO

    CALL timestop(handle)

  END SUBROUTINE purify_mo_none

! *****************************************************************************
!> \brief ...
!> \param qs_env ...
!> \param admm_env ...
!> \param para_env ...
!> \param matrix_s_aux_fit ...
!> \param matrix_s_mixed ...
!> \param mos ...
!> \param mos_aux_fit ...
!> \param geometry_did_change ...
!> \param blocked ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE fit_mo_coeffs(qs_env, admm_env, para_env, matrix_s_aux_fit, matrix_s_mixed, &
                                   mos, mos_aux_fit, geometry_did_change, blocked, error)
    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_s_aux_fit, &
                                                matrix_s_mixed
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos, mos_aux_fit
    LOGICAL, INTENT(IN)                      :: geometry_did_change, blocked
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'fit_mo_coeffs', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: blk, handle, iatom, jatom, &
                                                nao_aux_fit, nao_orb, nspins
    REAL(dp), DIMENSION(:, :), POINTER       :: sparse_block
    TYPE(cp_dbcsr_iterator)                  :: iter
    TYPE(cp_dbcsr_type), POINTER             :: matrix_s_tilde

    CALL timeset(routineN,handle)

    nao_aux_fit = admm_env%nao_aux_fit
    nao_orb = admm_env%nao_orb
    nspins = SIZE(mos)


    ! *** This part only depends on overlap matrices ==> needs only to be calculated if the geometry changed

    IF( geometry_did_change ) THEN
      IF(.NOT. blocked) THEN
         CALL copy_dbcsr_to_fm(matrix_s_aux_fit(1)%matrix,admm_env%S_inv,error)
      ELSE
         NULLIFY(matrix_s_tilde)
         ALLOCATE(matrix_s_tilde)
         CALL cp_dbcsr_init (matrix_s_tilde, error)
         CALL cp_dbcsr_create(matrix_s_tilde, 'MATRIX s_tilde', &
              cp_dbcsr_distribution(matrix_s_aux_fit(1)%matrix), dbcsr_type_symmetric, &
              cp_dbcsr_row_block_sizes(matrix_s_aux_fit(1)%matrix),&
              cp_dbcsr_col_block_sizes(matrix_s_aux_fit(1)%matrix), &
              cp_dbcsr_get_num_blocks(matrix_s_aux_fit(1)%matrix), &
              cp_dbcsr_get_data_size(matrix_s_aux_fit(1)%matrix),&
              cp_dbcsr_get_data_type(matrix_s_aux_fit(1)%matrix), &
              error=error)

         CALL cp_dbcsr_copy(matrix_s_tilde, matrix_s_aux_fit(1)%matrix, error=error)

         CALL cp_dbcsr_iterator_start(iter, matrix_s_tilde)
         DO WHILE (cp_dbcsr_iterator_blocks_left (iter))
           CALL cp_dbcsr_iterator_next_block(iter, iatom, jatom, sparse_block, blk)
           IF( admm_env%block_map(iatom,jatom) == 0 ) THEN
               sparse_block = 0.0_dp
           END IF
         END DO
         CALL cp_dbcsr_iterator_stop(iter)
         CALL copy_dbcsr_to_fm(matrix_s_tilde,admm_env%S_inv,error)
         CALL cp_dbcsr_deallocate_matrix(matrix_s_tilde,error)
      ENDIF

      CALL cp_fm_upper_to_full(admm_env%S_inv,admm_env%work_aux_aux,error=error)
      CALL cp_fm_to_fm(admm_env%S_inv, admm_env%S, error=error)

      CALL copy_dbcsr_to_fm(matrix_s_mixed(1)%matrix,admm_env%Q,error)

      !! Calculate S'_inverse
      CALL cp_fm_cholesky_decompose(admm_env%S_inv,error=error)
      CALL cp_fm_cholesky_invert(admm_env%S_inv,error=error)
      !! Symmetrize the guy
      CALL cp_fm_upper_to_full(admm_env%S_inv,admm_env%work_aux_aux,error=error)

      !! Calculate A=S'^(-1)*Q
      IF(blocked) THEN
        CALL cp_fm_set_all(admm_env%A, 0.0_dp, 1.0_dp, error)
      ELSE
        CALL cp_gemm('N','N',nao_aux_fit,nao_orb,nao_aux_fit,&
                      1.0_dp,admm_env%S_inv,admm_env%Q,0.0_dp,&
                      admm_env%A,error)

         ! this multiplication is apparent not need for purify_none
         !! B=Q^(T)*A
         CALL cp_gemm('T','N',nao_orb,nao_orb,nao_aux_fit,&
                         1.0_dp,admm_env%Q,admm_env%A,0.0_dp,&
                         admm_env%B,error)
      ENDIF
    END IF

    CALL timestop(handle)

  END SUBROUTINE fit_mo_coeffs


! *****************************************************************************
!> \brief Calculates the product Kohn-Sham-Matrix x mo_coeff for the auxiliary
!>        basis set and transforms it into the orbital basis. This is needed
!>        in order to use OT
!>
!> \param ispin which spin to transform
!> \param admm_env The ADMM env
!> \param mo_set ...
!> \param mo_coeff the MO coefficients from the orbital basis set
!> \param mo_coeff_aux_fit the MO coefficients from the auxiliary fitting basis set
!> \param mo_derivs KS x mo_coeff from the orbital basis set to which we add the
!>        auxiliary basis set part
!> \param mo_derivs_aux_fit ...
!> \param matrix_ks_aux_fit the Kohn-Sham matrix from the auxiliary fitting basis set
!> \param error ...
!>
!> \par History
!>      05.2008 created [Manuel Guidon]
!> \author Manuel Guidon
! *****************************************************************************
  SUBROUTINE merge_mo_derivs_diag(ispin, admm_env, mo_set, mo_coeff, mo_coeff_aux_fit, mo_derivs, &
                                  mo_derivs_aux_fit, matrix_ks_aux_fit, error)
    INTEGER, INTENT(IN)                      :: ispin
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(cp_fm_type), POINTER                :: mo_coeff, mo_coeff_aux_fit
    TYPE(cp_fm_p_type), DIMENSION(:), &
      POINTER                                :: mo_derivs, mo_derivs_aux_fit
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_ks_aux_fit
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'merge_mo_derivs_diag', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, i, j, nao_aux_fit, &
                                                nao_orb, nmo
    INTEGER, SAVE                            :: counter = 0
    REAL(dp)                                 :: eig_diff, pole, tmp32, tmp52, &
                                                tmp72, tmp92
    REAL(dp), DIMENSION(:), POINTER          :: occupation_numbers, &
                                                scaling_factor

    CALL timeset(routineN,handle)

    counter = counter + 1

    nao_aux_fit = admm_env%nao_aux_fit
    nao_orb = admm_env%nao_orb
    nmo = admm_env%nmo(ispin)

    CALL copy_dbcsr_to_fm(matrix_ks_aux_fit(ispin)%matrix,admm_env%K(ispin)%matrix,error)
    CALL cp_fm_upper_to_full(admm_env%K(ispin)%matrix,admm_env%work_aux_aux,error=error)

    CALL cp_gemm('N','N', nao_aux_fit, nmo, nao_aux_fit,&
                    1.0_dp,admm_env%K(ispin)%matrix,mo_coeff_aux_fit,0.0_dp,&
                    admm_env%H(ispin)%matrix,error)

    CALL get_mo_set(mo_set=mo_set, occupation_numbers=occupation_numbers)
    ALLOCATE(scaling_factor(SIZE(occupation_numbers)))
    scaling_factor = 2.0_dp*occupation_numbers

    CALL cp_fm_column_scale(admm_env%H(ispin)%matrix,scaling_factor)

    CALL cp_fm_to_fm(admm_env%H(ispin)%matrix, mo_derivs_aux_fit(ispin)%matrix, error=error)

    ! *** Add first term
    CALL cp_gemm('N','T', nao_aux_fit, nmo, nmo,&
                    1.0_dp,admm_env%H(ispin)%matrix,admm_env%lambda_inv_sqrt(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_nmo(ispin)%matrix,error)
    CALL cp_gemm('T','N', nao_orb, nmo, nao_aux_fit,&
                    1.0_dp,admm_env%A,admm_env%work_aux_nmo(ispin)%matrix,0.0_dp,&
                    admm_env%mo_derivs_tmp(ispin)%matrix,error)


    ! *** Construct Matrix M for Hadamard Product
    pole = 0.0_dp
    DO i=1,nmo
      DO j=i,nmo
        eig_diff = ( admm_env%eigvals_lambda(ispin)%eigvals%data(i) -&
                     admm_env%eigvals_lambda(ispin)%eigvals%data(j) )
        ! *** two eigenvalues could be the degenerated. In that case use 2nd order formula for the poles
        IF( ABS(eig_diff) < 0.0001_dp ) THEN
          tmp32 = 1.0_dp/SQRT(admm_env%eigvals_lambda(ispin)%eigvals%data(j))**3
          tmp52 = tmp32/admm_env%eigvals_lambda(ispin)%eigvals%data(j)*eig_diff
          tmp72 = tmp52/admm_env%eigvals_lambda(ispin)%eigvals%data(j)*eig_diff
          tmp92 = tmp72/admm_env%eigvals_lambda(ispin)%eigvals%data(j)*eig_diff

          pole = -0.5_dp*tmp32 + 3.0_dp/8.0_dp*tmp52 - 5.0_dp/16.0_dp*tmp72 + 35.0_dp/128.0_dp*tmp92
          CALL cp_fm_set_element(admm_env%M(ispin)%matrix,i,j,pole,error)
        ELSE
          pole = 1.0_dp/SQRT(admm_env%eigvals_lambda(ispin)%eigvals%data(i))
          pole = pole - 1.0_dp/SQRT(admm_env%eigvals_lambda(ispin)%eigvals%data(j))
          pole = pole/(admm_env%eigvals_lambda(ispin)%eigvals%data(i)-&
                       admm_env%eigvals_lambda(ispin)%eigvals%data(j))
          CALL cp_fm_set_element(admm_env%M(ispin)%matrix,i,j,pole,error)
        END IF
      END DO
    END DO
    CALL cp_fm_upper_to_full(admm_env%M(ispin)%matrix,admm_env%work_nmo_nmo1(ispin)%matrix,error=error)

    ! *** 2nd term to be added to fm_H

    !! Part 1: B^(T)*C* R*[R^(T)*c^(T)*A^(T)*H_aux_fit*R x M]*R^(T)
    !! Part 2: B*C*(R*[R^(T)*c^(T)*A^(T)*H_aux_fit*R x M]*R^(T))^(T)

    ! *** H'*R
    CALL cp_gemm('N','N', nao_aux_fit, nmo, nmo,&
                    1.0_dp,admm_env%H(ispin)%matrix,admm_env%R(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_nmo(ispin)%matrix,error)
    ! *** A^(T)*H'*R
    CALL cp_gemm('T','N', nao_orb, nmo, nao_aux_fit,&
                    1.0_dp,admm_env%A,admm_env%work_aux_nmo(ispin)%matrix,0.0_dp,&
                    admm_env%work_orb_nmo(ispin)%matrix,error)
    ! *** c^(T)*A^(T)*H'*R
    CALL cp_gemm('T','N', nmo, nmo, nao_orb,&
                    1.0_dp,mo_coeff,admm_env%work_orb_nmo(ispin)%matrix,0.0_dp,&
                    admm_env%work_nmo_nmo1(ispin)%matrix,error)
    ! *** R^(T)*c^(T)*A^(T)*H'*R
    CALL cp_gemm('T','N', nmo, nmo, nmo,&
                    1.0_dp,admm_env%R(ispin)%matrix,admm_env%work_nmo_nmo1(ispin)%matrix,0.0_dp,&
                    admm_env%work_nmo_nmo2(ispin)%matrix,error)
    ! *** R^(T)*c^(T)*A^(T)*H'*R x M
    CALL cp_fm_schur_product(admm_env%work_nmo_nmo2(ispin)%matrix,&
                             admm_env%M(ispin)%matrix,admm_env%work_nmo_nmo1(ispin)%matrix,error)
    ! *** R* (R^(T)*c^(T)*A^(T)*H'*R x M)
    CALL cp_gemm('N','N', nmo, nmo, nmo,&
                    1.0_dp,admm_env%R(ispin)%matrix,admm_env%work_nmo_nmo1(ispin)%matrix,0.0_dp,&
                    admm_env%work_nmo_nmo2(ispin)%matrix,error)

    ! *** R* (R^(T)*c^(T)*A^(T)*H'*R x M) *R^(T)
    CALL cp_gemm('N','T', nmo, nmo, nmo,&
                    1.0_dp,admm_env%work_nmo_nmo2(ispin)%matrix,admm_env%R(ispin)%matrix,0.0_dp,&
                    admm_env%R_schur_R_t(ispin)%matrix,error)

    ! *** B^(T)*c
    CALL cp_gemm('T','N', nao_orb, nmo, nao_orb,&
                    1.0_dp,admm_env%B,mo_coeff,0.0_dp,&
                    admm_env%work_orb_nmo(ispin)%matrix,error)

    ! *** Add first term to fm_H
    ! *** B^(T)*c* R* (R^(T)*c^(T)*A^(T)*H'*R x M) *R^(T)
    CALL cp_gemm('N','N', nao_orb, nmo, nmo,&
                    1.0_dp,admm_env%work_orb_nmo(ispin)%matrix,admm_env%R_schur_R_t(ispin)%matrix,1.0_dp,&
                    admm_env%mo_derivs_tmp(ispin)%matrix,error)

    ! *** Add second term to fm_H
    ! *** B*C *[ R* (R^(T)*c^(T)*A^(T)*H'*R x M) *R^(T)]^(T)
    CALL cp_gemm('N','T', nao_orb, nmo, nmo,&
                    1.0_dp,admm_env%work_orb_nmo(ispin)%matrix,admm_env%R_schur_R_t(ispin)%matrix,1.0_dp,&
                    admm_env%mo_derivs_tmp(ispin)%matrix,error)

    DO i = 1,SIZE(scaling_factor)
      scaling_factor(i) = 1.0_dp/scaling_factor(i)
    END DO

    CALL cp_fm_column_scale(admm_env%mo_derivs_tmp(ispin)%matrix,scaling_factor)

    CALL cp_fm_scale_and_add(1.0_dp,mo_derivs(ispin)%matrix,1.0_dp,admm_env%mo_derivs_tmp(ispin)%matrix,error)

    DEALLOCATE(scaling_factor)

    CALL timestop(handle)

  END SUBROUTINE merge_mo_derivs_diag

! *****************************************************************************
!> \brief ...
!> \param ispin ...
!> \param admm_env ...
!> \param mo_set ...
!> \param mo_coeff ...
!> \param mo_coeff_aux_fit ...
!> \param matrix_ks_aux_fit ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE calc_aux_mo_derivs_none(ispin, admm_env, mo_set, mo_coeff, mo_coeff_aux_fit,  &
                                  matrix_ks_aux_fit, error)
    INTEGER, INTENT(IN)                      :: ispin
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(cp_fm_type), POINTER                :: mo_coeff, mo_coeff_aux_fit
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_ks_aux_fit
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'calc_aux_mo_derivs_none', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, nao_aux_fit, nao_orb, &
                                                nmo
    INTEGER, SAVE                            :: counter = 0
    REAL(dp), DIMENSION(:), POINTER          :: occupation_numbers, &
                                                scaling_factor

    CALL timeset(routineN,handle)

    counter = counter + 1

    nao_aux_fit = admm_env%nao_aux_fit
    nao_orb = admm_env%nao_orb
    nmo = admm_env%nmo(ispin)

    ! just calculate the mo derivs in the aux basis  
    ! only needs to be done on the converged ks matrix for the force calc
    ! Note with OT and purification NONE, the merging of the derivs
    ! happens implicitly because the KS matrices have been already been merged
    ! and adding them here would be double counting.

    CALL copy_dbcsr_to_fm(matrix_ks_aux_fit(ispin)%matrix,admm_env%K(ispin)%matrix,error)
    CALL cp_fm_upper_to_full(admm_env%K(ispin)%matrix,admm_env%work_aux_aux,error=error)

    CALL cp_gemm('N','N', nao_aux_fit, nmo, nao_aux_fit,&
                    1.0_dp,admm_env%K(ispin)%matrix,mo_coeff_aux_fit,0.0_dp,&
                    admm_env%H(ispin)%matrix,error)

    CALL get_mo_set(mo_set=mo_set, occupation_numbers=occupation_numbers)
    ALLOCATE(scaling_factor(SIZE(occupation_numbers)))
    scaling_factor = 2.0_dp*occupation_numbers
    CALL cp_fm_column_scale(admm_env%H(ispin)%matrix,scaling_factor)

    DEALLOCATE(scaling_factor)

    CALL timestop(handle)

  END SUBROUTINE calc_aux_mo_derivs_none

! *****************************************************************************
!> \brief ...
!> \param ispin ...
!> \param admm_env ...
!> \param mo_set ...
!> \param mo_coeff ...
!> \param mo_coeff_aux_fit ...
!> \param mo_derivs ...
!> \param mo_derivs_aux_fit ...
!> \param matrix_ks_aux_fit ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE merge_mo_derivs_no_diag(ispin, admm_env, mo_set, mo_coeff, mo_coeff_aux_fit, mo_derivs, &
                                  mo_derivs_aux_fit, matrix_ks_aux_fit, error)
    INTEGER, INTENT(IN)                      :: ispin
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(cp_fm_type), POINTER                :: mo_coeff, mo_coeff_aux_fit
    TYPE(cp_fm_p_type), DIMENSION(:), &
      POINTER                                :: mo_derivs, mo_derivs_aux_fit
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_ks_aux_fit
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'merge_mo_derivs_no_diag', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, nao_aux_fit, nao_orb, &
                                                nmo
    INTEGER, SAVE                            :: counter = 0
    REAL(dp), DIMENSION(:), POINTER          :: occupation_numbers, &
                                                scaling_factor

    CALL timeset(routineN,handle)

    counter = counter + 1

    nao_aux_fit = admm_env%nao_aux_fit
    nao_orb = admm_env%nao_orb
    nmo = admm_env%nmo(ispin)

    CALL copy_dbcsr_to_fm(matrix_ks_aux_fit(ispin)%matrix,admm_env%K(ispin)%matrix,error)
    CALL cp_fm_upper_to_full(admm_env%K(ispin)%matrix,admm_env%work_aux_aux,error=error)

    CALL get_mo_set(mo_set=mo_set, occupation_numbers=occupation_numbers)
    ALLOCATE(scaling_factor(SIZE(occupation_numbers)))
    scaling_factor = 0.5_dp


    !! ** calculate first part
    CALL cp_gemm('N', 'N',  nao_aux_fit, nmo, nmo,&
                    1.0_dp,admm_env%C_hat(ispin)%matrix,admm_env%lambda_inv(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_nmo(ispin)%matrix,error)
    CALL cp_gemm('N', 'N',  nao_aux_fit, nmo, nao_aux_fit,&
                    1.0_dp,admm_env%K(ispin)%matrix,admm_env%work_aux_nmo(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_nmo2(ispin)%matrix,error)
    CALL cp_gemm('T', 'N',  nao_orb, nmo, nao_aux_fit,&
                    2.0_dp,admm_env%A,admm_env%work_aux_nmo2(ispin)%matrix,0.0_dp,&
                    admm_env%mo_derivs_tmp(ispin)%matrix,error)
    !! ** calculate second part
    CALL cp_gemm('T', 'N',  nmo, nmo, nao_aux_fit,&
                    1.0_dp,admm_env%work_aux_nmo(ispin)%matrix,admm_env%work_aux_nmo2(ispin)%matrix,0.0_dp,&
                    admm_env%work_orb_orb,error)
    CALL cp_gemm('N', 'N',  nao_aux_fit, nmo, nmo,&
                    1.0_dp,admm_env%C_hat(ispin)%matrix,admm_env%work_orb_orb,0.0_dp,&
                    admm_env%work_aux_orb,error)
    CALL cp_gemm('N', 'N',  nao_aux_fit, nmo, nao_aux_fit,&
                    1.0_dp,admm_env%S,admm_env%work_aux_orb,0.0_dp,&
                    admm_env%work_aux_nmo(ispin)%matrix,error)
    CALL cp_gemm('T', 'N',  nao_orb, nmo, nao_aux_fit,&
                    -2.0_dp,admm_env%A,admm_env%work_aux_nmo(ispin)%matrix,1.0_dp,&
                    admm_env%mo_derivs_tmp(ispin)%matrix,error)

    CALL cp_fm_column_scale(admm_env%mo_derivs_tmp(ispin)%matrix,scaling_factor)

    CALL cp_fm_scale_and_add(1.0_dp,mo_derivs(ispin)%matrix,1.0_dp,admm_env%mo_derivs_tmp(ispin)%matrix,error)

    DEALLOCATE(scaling_factor)

    CALL timestop(handle)

  END SUBROUTINE merge_mo_derivs_no_diag


! *****************************************************************************
!> \brief Calculates contribution of forces due to basis transformation
!>
!>        dE/dR = dE/dC'*dC'/dR
!>        dE/dC = Ks'*c'*occ = H'
!>
!>        dC'/dR = - tr(A*lambda^(-1/2)*H'^(T)*S^(-1) * dS'/dR)
!>                 - tr(A*C*Y^(T)*C^(T)*Q^(T)*A^(T) * dS'/dR)
!>                 + tr(C*lambda^(-1/2)*H'^(T)*S^(-1) * dQ/dR)
!>                 + tr(A*C*Y^(T)*c^(T) * dQ/dR)
!>                 + tr(C*Y^(T)*C^(T)*A^(T) * dQ/dR)
!>
!>        where
!>
!>        A = S'^(-1)*Q
!>        lambda = C^(T)*B*C
!>        B = Q^(T)*A
!>        Y = R*[ (R^(T)*C^(T)*A^(T)*H'*R) xx M ]*R^(T)
!>        lambda = R*D*R^(T)
!>        Mij = Poles-Matrix (see above)
!>        xx = schur product
!>
!> \param qs_env the QS environment
!> \param para_env ...
!> \param ispin which spin to transform
!> \param admm_env The ADMM env
!> \param mo_coeff the MO coefficients from the orbital basis set
!> \param matrix_s_aux_fit overlap matrix from auxiliary fitting basis
!> \param matrix_s_aux_fit_vs_orb mixed orbital/aux fit overlap matrix
!> \param logger ...
!> \param iw ...
!> \param use_virial ...
!> \param error ...
!>
!> \par History
!>      05.2008 created [Manuel Guidon]
!> \author Manuel Guidon
! *****************************************************************************
  SUBROUTINE calc_mixed_overlap_force(qs_env, para_env, ispin, admm_env, mo_coeff,  &
                                      matrix_s_aux_fit, matrix_s_aux_fit_vs_orb, logger,&
                                      iw, use_virial, error)

    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(cp_para_env_type), POINTER          :: para_env
    INTEGER, INTENT(IN)                      :: ispin
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(cp_fm_type), POINTER                :: mo_coeff
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_s_aux_fit, &
                                                matrix_s_aux_fit_vs_orb
    TYPE(cp_logger_type), POINTER            :: logger
    INTEGER                                  :: iw
    LOGICAL, INTENT(IN)                      :: use_virial
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'calc_mixed_overlap_force', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, nao_aux_fit, nao_orb, &
                                                natom, neighbor_list_id, nmo
    LOGICAL                                  :: failure
    REAL(KIND=dp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: admm_force
    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(cp_dbcsr_type), POINTER             :: matrix_w_q, matrix_w_s
    TYPE(qs_force_type), DIMENSION(:), &
      POINTER                                :: force

    CALL timeset(routineN,handle)
    failure=.FALSE.

    NULLIFY(matrix_w_q, matrix_w_s)

    nao_aux_fit = admm_env%nao_aux_fit
    nao_orb = admm_env%nao_orb
    nmo = admm_env%nmo(ispin)

    ! *** forces are only implemented for mo_diag or none and basis_projection ***
    IF (admm_env%block_dm) THEN
      CPPostcondition(.FALSE.,cp_failure_level,routineP,error,failure)
    ENDIF

    IF (.NOT.(admm_env%purification_method==do_admm_purify_mo_diag .OR. &
               admm_env%purification_method==do_admm_purify_none)) THEN
      CPPostcondition(.FALSE.,cp_failure_level,routineP,error,failure)
    ENDIF

    ! *** Create sparse work matrices
    CALL get_qs_env(qs_env=qs_env,&
                    neighbor_list_id=neighbor_list_id,&
                    error=error)

    ALLOCATE(matrix_w_s)
    CALL cp_dbcsr_init (matrix_w_s, error)
    CALL cp_dbcsr_create(matrix_w_s, 'W MATRIX AUX S', &
         cp_dbcsr_distribution(matrix_s_aux_fit(1)%matrix), dbcsr_type_no_symmetry, &
         cp_dbcsr_row_block_sizes(matrix_s_aux_fit(1)%matrix),&
         cp_dbcsr_col_block_sizes(matrix_s_aux_fit(1)%matrix), &
         cp_dbcsr_get_num_blocks(matrix_s_aux_fit(1)%matrix), &
         cp_dbcsr_get_data_size(matrix_s_aux_fit(1)%matrix),&
         cp_dbcsr_get_data_type(matrix_s_aux_fit(1)%matrix), &
         error=error)
    CALL cp_dbcsr_alloc_block_from_nbl(matrix_w_s,qs_env%sab_aux_fit_asymm,error=error)

    ALLOCATE(matrix_w_q)
    CALL cp_dbcsr_init(matrix_w_q, error=error)
    CALL cp_dbcsr_copy(matrix_w_q,matrix_s_aux_fit_vs_orb(1)%matrix,&
                    "W MATRIX AUX Q",error=error)

    ! *** S'^(-T)*H'
    IF (.NOT. admm_env%purification_method==do_admm_purify_none) THEN
    CALL cp_gemm('T', 'N', nao_aux_fit, nmo, nao_aux_fit,&
                    1.0_dp,admm_env%S_inv,qs_env%mo_derivs_aux_fit(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_nmo(ispin)%matrix,error)
    ELSE

    CALL cp_gemm('T', 'N', nao_aux_fit, nmo, nao_aux_fit,&
                    1.0_dp,admm_env%S_inv,admm_env%H(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_nmo(ispin)%matrix,error)
    END IF

    ! *** S'^(-T)*H'*Lambda^(-T/2)
    CALL cp_gemm('N', 'T',  nao_aux_fit,nmo, nmo,&
                    1.0_dp,admm_env%work_aux_nmo(ispin)%matrix,admm_env%lambda_inv_sqrt(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_nmo2(ispin)%matrix,error)

    ! *** C*Lambda^(-1/2)*H'^(T)*S'^(-1) minus sign due to force = -dE/dR
    CALL cp_gemm('N', 'T',  nao_aux_fit, nao_orb, nmo,&
                    -1.0_dp,admm_env%work_aux_nmo2(ispin)%matrix,mo_coeff,0.0_dp,&
                    admm_env%work_aux_orb,error)

    ! *** A*C*Lambda^(-1/2)*H'^(T)*S'^(-1), minus sign to recover from above
    CALL cp_gemm('N', 'T',  nao_aux_fit, nao_aux_fit, nao_orb,&
                    -1.0_dp,admm_env%work_aux_orb,admm_env%A,0.0_dp,&
                    admm_env%work_aux_aux,error)


    IF (.NOT. (admm_env%purification_method==do_admm_purify_none)) THEN
       ! *** C*Y
       CALL cp_gemm('N', 'N',  nao_orb, nmo, nmo,&
                    1.0_dp,mo_coeff,admm_env%R_schur_R_t(ispin)%matrix,0.0_dp,&
                    admm_env%work_orb_nmo(ispin)%matrix,error)
       ! *** C*Y^(T)*C^(T)
       CALL cp_gemm('N', 'T',  nao_orb, nao_orb, nmo,&
                    1.0_dp,mo_coeff,admm_env%work_orb_nmo(ispin)%matrix,0.0_dp,&
                    admm_env%work_orb_orb,error)
       ! *** A*C*Y^(T)*C^(T) Add to work aux_orb, minus sign due to force = -dE/dR
       CALL cp_gemm('N', 'N',  nao_aux_fit, nao_orb, nao_orb,&
                    -1.0_dp,admm_env%A,admm_env%work_orb_orb,1.0_dp,&
                    admm_env%work_aux_orb,error)

       ! *** C*Y^(T)
       CALL cp_gemm('N', 'T',  nao_orb, nmo, nmo,&
                    1.0_dp,mo_coeff,admm_env%R_schur_R_t(ispin)%matrix,0.0_dp,&
                    admm_env%work_orb_nmo(ispin)%matrix,error)
       ! *** C*Y*C^(T)
       CALL cp_gemm('N', 'T',  nao_orb, nao_orb, nmo,&
                    1.0_dp,mo_coeff,admm_env%work_orb_nmo(ispin)%matrix,0.0_dp,&
                    admm_env%work_orb_orb,error)
       ! *** A*C*Y*C^(T) Add to work aux_orb, minus sign due to -dE/dR
       CALL cp_gemm('N', 'N',  nao_aux_fit, nao_orb, nao_orb,&
                    -1.0_dp,admm_env%A,admm_env%work_orb_orb,1.0_dp,&
                    admm_env%work_aux_orb,error)
    END IF

    ! *** copy to sparse matrix
    CALL copy_fm_to_dbcsr(admm_env%work_aux_orb, matrix_w_q,keep_sparsity=.TRUE.,&
         error=error)

    IF (.NOT. (admm_env%purification_method==do_admm_purify_none)) THEN
       ! *** A*C*Y^(T)*C^(T)
       CALL cp_gemm('N', 'N',  nao_aux_fit, nao_orb, nao_orb,&
                    1.0_dp,admm_env%A,admm_env%work_orb_orb,0.0_dp,&
                    admm_env%work_aux_orb,error)
       ! *** A*C*Y^(T)*C^(T)*A^(T) add to aux_aux, minus sign cancels
       CALL cp_gemm('N', 'T',  nao_aux_fit, nao_aux_fit, nao_orb,&
                    1.0_dp,admm_env%work_aux_orb,admm_env%A,1.0_dp,&
                    admm_env%work_aux_aux,error)
    END IF

    ! *** copy to sparse matrix
    CALL copy_fm_to_dbcsr(admm_env%work_aux_aux, matrix_w_s,keep_sparsity=.TRUE.,&
         error=error)

    ! allocate force vector
    CALL get_qs_env(qs_env=qs_env,natom=natom,error=error)
    ALLOCATE(admm_force(3,natom))
    admm_force = 0.0_dp
    CALL build_overlap_force(qs_env, admm_force,&
         basis_set_id_a=use_aux_fit_basis_set, basis_set_id_b=use_aux_fit_basis_set, &
         sab_nl=qs_env%sab_aux_fit_asymm, matrix_p=matrix_w_s, error=error)
    CALL build_overlap_force(qs_env, admm_force,&
         basis_set_id_a=use_aux_fit_basis_set, basis_set_id_b=use_orb_basis_set, &
         sab_nl=qs_env%sab_aux_fit_vs_orb, matrix_p=matrix_w_q, error=error)
    ! add forces
    CALL get_qs_env(qs_env=qs_env,atomic_kind_set=atomic_kind_set,&
                    force=force,error=error)
    CALL add_qs_force(admm_force, force, "overlap_admm", atomic_kind_set, error)
    DEALLOCATE(admm_force)

    IF (BTEST(cp_print_key_should_output(logger%iter_info,&
         qs_env%input,"DFT%PRINT%AO_MATRICES/W_MATRIX_AUX_FIT",error=error),cp_p_file)) THEN
       iw = cp_print_key_unit_nr(logger,qs_env%input,"DFT%PRINT%AO_MATRICES/W_MATRIX_AUX_FIT",&
            extension=".Log",error=error)
       CALL cp_dbcsr_write_sparse_matrix(matrix_w_s,4,6,qs_env,para_env,output_unit=iw,error=error)
       CALL cp_print_key_finished_output(iw,logger,qs_env%input,&
            "DFT%PRINT%AO_MATRICES/W_MATRIX_AUX_FIT", error=error)
    END IF
    IF (BTEST(cp_print_key_should_output(logger%iter_info,&
         qs_env%input,"DFT%PRINT%AO_MATRICES/W_MATRIX_AUX_FIT",error=error),cp_p_file)) THEN
       iw = cp_print_key_unit_nr(logger,qs_env%input,"DFT%PRINT%AO_MATRICES/W_MATRIX_AUX_FIT",&
            extension=".Log",error=error)
       CALL cp_dbcsr_write_sparse_matrix(matrix_w_q,4,6,qs_env,para_env,output_unit=iw,error=error)
       CALL cp_print_key_finished_output(iw,logger,qs_env%input,&
            "DFT%PRINT%AO_MATRICES/W_MATRIX_AUX_FIT", error=error)
    END IF

    ! *** Deallocated weighted density matrices
    CALL cp_dbcsr_deallocate_matrix(matrix_w_s,error)
    CALL cp_dbcsr_deallocate_matrix(matrix_w_q,error)

    CALL timestop(handle)

  END SUBROUTINE calc_mixed_overlap_force

! *****************************************************************************
!> \brief This routine modifies the xc section depending on the potential type
!>        used for the HF exchange and the resulting correction term. Currently
!>        three types of corrections are implemented:
!>
!>        coulomb:     Ex,hf = Ex,hf' + (PBEx-PBEx')
!>        shortrange:  Ex,hf = Ex,hf' + (XWPBEX-XWPBEX')
!>        truncated:   Ex,hf = Ex,hf' + ( (XWPBEX0-PBE_HOLE_TC_LR) -(XWPBEX0-PBE_HOLE_TC_LR)' )
!>
!>        with ' denoting the auxiliary basis set and
!>
!>          PBEx:           PBE exchange functional
!>          XWPBEX:         PBE exchange hole for short-range potential (erfc(omega*r)/r)
!>          XWPBEX0:        PBE exchange hole for standard coulomb potential
!>          PBE_HOLE_TC_LR: PBE exchange hole for longrange truncated coulomb potential
!>
!>
!> \param qs_env the qs environment
!> \param xc_section the original xc_section
!> \param admm_env the ADMM environment
!> \param error ...
!>
!> \par History
!>      12.2009 created [Manuel Guidon]
!> \author Manuel Guidon
! *****************************************************************************
  SUBROUTINE create_admm_xc_section(qs_env, xc_section, admm_env,error)
    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(section_vals_type), POINTER         :: xc_section
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'create_admm_xc_section', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: hfx_potential_type, ifun, nfun
    LOGICAL                                  :: failure, funct_found
    REAL(dp)                                 :: cutoff_radius, hfx_fraction, &
                                                omega, scale_x
    TYPE(section_vals_type), POINTER         :: xc_fun, xc_fun_section

    NULLIFY(admm_env%xc_section_aux, admm_env%xc_section_primary)
    failure=.FALSE.

    !! ** Duplicate existing xc-section

    CALL section_vals_duplicate(xc_section,admm_env%xc_section_aux,error=error)
    CALL section_vals_duplicate(xc_section,admm_env%xc_section_primary,error=error)
    !** Now modify the auxiliary basis
    !** First remove all functionals
    xc_fun_section => section_vals_get_subs_vals(admm_env%xc_section_aux,"XC_FUNCTIONAL",error=error)

    !* Overwrite possible shortcut
    CALL section_vals_val_set(xc_fun_section,"_SECTION_PARAMETERS_",&
                              i_val=xc_funct_no_shortcut,error=error)

    !** Get number of Functionals in the list
    ifun = 0
    nfun = 0
    DO
      ifun = ifun+1
      xc_fun => section_vals_get_subs_vals2(xc_fun_section,i_section=ifun,error=error)
      IF (.NOT.ASSOCIATED(xc_fun)) EXIT
      nfun = nfun + 1
    END DO

    ifun = 0
    DO ifun = 1,nfun
      xc_fun => section_vals_get_subs_vals2(xc_fun_section,i_section=1,error=error)
      IF (.NOT.ASSOCIATED(xc_fun)) EXIT
      CALL section_vals_remove_values(xc_fun, error=error)
    END DO

    hfx_potential_type = qs_env%x_data(1,1)%potential_parameter%potential_type
    hfx_fraction = qs_env%x_data(1,1)%general_parameter%fraction

    !! ** Add functionals evaluated with auxiliary basis
    SELECT CASE (hfx_potential_type)
    CASE (do_hfx_potential_coulomb)
      CALL section_vals_val_set(xc_fun_section,"PBE%_SECTION_PARAMETERS_",&
                                l_val=.TRUE.,error=error)
      CALL section_vals_val_set(xc_fun_section,"PBE%SCALE_X",&
                                r_val=-hfx_fraction,error=error)
      CALL section_vals_val_set(xc_fun_section,"PBE%SCALE_C",&
                                r_val=0.0_dp,error=error)
    CASE (do_hfx_potential_short)
      omega =  qs_env%x_data(1,1)%potential_parameter%omega
      CALL section_vals_val_set(xc_fun_section,"XWPBE%_SECTION_PARAMETERS_",&
                                l_val=.TRUE.,error=error)
      CALL section_vals_val_set(xc_fun_section,"XWPBE%SCALE_X",&
                                r_val=-hfx_fraction,error=error)
      CALL section_vals_val_set(xc_fun_section,"XWPBE%SCALE_X0",&
                                r_val=0.0_dp,error=error)
      CALL section_vals_val_set(xc_fun_section,"XWPBE%OMEGA",&
                                r_val=omega,error=error)
    CASE (do_hfx_potential_truncated)
      cutoff_radius = qs_env%x_data(1,1)%potential_parameter%cutoff_radius
      CALL section_vals_val_set(xc_fun_section,"PBE_HOLE_T_C_LR%_SECTION_PARAMETERS_",&
                                l_val=.TRUE.,error=error)
      CALL section_vals_val_set(xc_fun_section,"PBE_HOLE_T_C_LR%SCALE_X",&
                                r_val=hfx_fraction,error=error)
      CALL section_vals_val_set(xc_fun_section,"PBE_HOLE_T_C_LR%CUTOFF_RADIUS",&
                                r_val=cutoff_radius,error=error)
      CALL section_vals_val_set(xc_fun_section,"XWPBE%_SECTION_PARAMETERS_",&
                                l_val=.TRUE.,error=error)
      CALL section_vals_val_set(xc_fun_section,"XWPBE%SCALE_X",&
                                r_val=0.0_dp,error=error)
      CALL section_vals_val_set(xc_fun_section,"XWPBE%SCALE_X0",&
                                r_val=-hfx_fraction,error=error)
    CASE DEFAULT
      CPPostcondition(.FALSE.,cp_failure_level,routineP,error,failure)
    END SELECT


    !** Now modify the functionals for the primary basis
    xc_fun_section => section_vals_get_subs_vals(admm_env%xc_section_primary,"XC_FUNCTIONAL",error=error)
    !* Overwrite possible shortcut
    CALL section_vals_val_set(xc_fun_section,"_SECTION_PARAMETERS_",&
                              i_val=xc_funct_no_shortcut,error=error)


    SELECT CASE (hfx_potential_type)
    CASE (do_hfx_potential_coulomb)
      ifun = 0
      funct_found = .FALSE.
      DO
        ifun = ifun+1
        xc_fun => section_vals_get_subs_vals2(xc_fun_section,i_section=ifun,error=error)
        IF (.NOT.ASSOCIATED(xc_fun)) EXIT
        IF( xc_fun%section%name == "PBE" ) THEN
          funct_found = .TRUE.
        END IF
      END DO
      IF( .NOT. funct_found ) THEN
        CALL section_vals_val_set(xc_fun_section,"PBE%_SECTION_PARAMETERS_",&
                                  l_val=.TRUE.,error=error)
        CALL section_vals_val_set(xc_fun_section,"PBE%SCALE_X",&
                                  r_val=hfx_fraction,error=error)
        CALL section_vals_val_set(xc_fun_section,"PBE%SCALE_C",&
                                  r_val=0.0_dp,error=error)
      ELSE
        CALL section_vals_val_get(xc_fun_section,"PBE%SCALE_X",&
                                  r_val=scale_x,error=error)
        scale_x = scale_x + hfx_fraction
        CALL section_vals_val_set(xc_fun_section,"PBE%SCALE_X",&
                                  r_val=scale_x,error=error)
      END IF
    CASE (do_hfx_potential_short)
      omega =  qs_env%x_data(1,1)%potential_parameter%omega
      ifun = 0
      funct_found = .FALSE.
      DO
        ifun = ifun+1
        xc_fun => section_vals_get_subs_vals2(xc_fun_section,i_section=ifun,error=error)
        IF (.NOT.ASSOCIATED(xc_fun)) EXIT
        IF( xc_fun%section%name == "XWPBE" ) THEN
          funct_found = .TRUE.
        END IF
      END DO
      IF( .NOT. funct_found ) THEN
        CALL section_vals_val_set(xc_fun_section,"XWPBE%_SECTION_PARAMETERS_",&
                                  l_val=.TRUE.,error=error)
        CALL section_vals_val_set(xc_fun_section,"XWPBE%SCALE_X",&
                                  r_val=hfx_fraction,error=error)
        CALL section_vals_val_set(xc_fun_section,"XWPBE%SCALE_X0",&
                                  r_val=0.0_dp,error=error)
        CALL section_vals_val_set(xc_fun_section,"XWPBE%OMEGA",&
                                  r_val=omega,error=error)
      ELSE
        CALL section_vals_val_get(xc_fun_section,"XWPBE%SCALE_X",&
                                  r_val=scale_x,error=error)
        scale_x = scale_x + hfx_fraction
        CALL section_vals_val_set(xc_fun_section,"XWPBE%SCALE_X",&
                                  r_val=scale_x,error=error)
      END IF
    CASE (do_hfx_potential_truncated)
      cutoff_radius =  qs_env%x_data(1,1)%potential_parameter%cutoff_radius
      ifun = 0
      funct_found = .FALSE.
      DO
        ifun = ifun+1
        xc_fun => section_vals_get_subs_vals2(xc_fun_section,i_section=ifun,error=error)
        IF (.NOT.ASSOCIATED(xc_fun)) EXIT
        IF( xc_fun%section%name == "PBE_HOLE_T_C_LR" ) THEN
          funct_found = .TRUE.
        END IF
      END DO
      IF( .NOT. funct_found ) THEN
        CALL section_vals_val_set(xc_fun_section,"PBE_HOLE_T_C_LR%_SECTION_PARAMETERS_",&
                                  l_val=.TRUE.,error=error)
        CALL section_vals_val_set(xc_fun_section,"PBE_HOLE_T_C_LR%SCALE_X",&
                                  r_val=-hfx_fraction,error=error)
        CALL section_vals_val_set(xc_fun_section,"PBE_HOLE_T_C_LR%CUTOFF_RADIUS",&
                                  r_val=cutoff_radius,error=error)

      ELSE
        CALL section_vals_val_get(xc_fun_section,"PBE_HOLE_T_C_LR%SCALE_X",&
                                  r_val=scale_x,error=error)
        scale_x = scale_x - hfx_fraction
        CALL section_vals_val_set(xc_fun_section,"PBE_HOLE_T_C_LR%SCALE_X",&
                                  r_val=scale_x,error=error)
        CALL section_vals_val_set(xc_fun_section,"PBE_HOLE_T_C_LR%CUTOFF_RADIUS",&
                                  r_val=cutoff_radius,error=error)
      END IF
      ifun = 0
      funct_found = .FALSE.
      DO
        ifun = ifun+1
        xc_fun => section_vals_get_subs_vals2(xc_fun_section,i_section=ifun,error=error)
        IF (.NOT.ASSOCIATED(xc_fun)) EXIT
        IF( xc_fun%section%name == "XWPBE" ) THEN
          funct_found = .TRUE.
        END IF
      END DO
      IF( .NOT. funct_found ) THEN
        CALL section_vals_val_set(xc_fun_section,"XWPBE%_SECTION_PARAMETERS_",&
                                  l_val=.TRUE.,error=error)
        CALL section_vals_val_set(xc_fun_section,"XWPBE%SCALE_X0",&
                                  r_val=hfx_fraction,error=error)
        CALL section_vals_val_set(xc_fun_section,"XWPBE%SCALE_X",&
                                  r_val=0.0_dp,error=error)

      ELSE
        CALL section_vals_val_get(xc_fun_section,"XWPBE%SCALE_X0",&
                                  r_val=scale_x,error=error)
        scale_x = scale_x + hfx_fraction
        CALL section_vals_val_set(xc_fun_section,"XWPBE%SCALE_X0",&
                                  r_val=scale_x,error=error)
      END IF

    END SELECT


    IF( 1==0 ) THEN
      WRITE(*,*) "primary"
      xc_fun_section => section_vals_get_subs_vals(admm_env%xc_section_primary,"XC_FUNCTIONAL",error=error)
      ifun = 0
      funct_found = .FALSE.
      DO
        ifun = ifun+1
        xc_fun => section_vals_get_subs_vals2(xc_fun_section,i_section=ifun,error=error)
        IF (.NOT.ASSOCIATED(xc_fun)) EXIT

        scale_x=-1000.0_dp
        IF(xc_fun%section%name /= "LYP" .AND. xc_fun%section%name /= "VWN") THEN
          CALL section_vals_val_get(xc_fun,"SCALE_X",&
                                      r_val=scale_x,error=error)
        END IF
        IF( xc_fun%section%name == "XWPBE" ) THEN
          CALL section_vals_val_get(xc_fun,"SCALE_X0",&
                                    r_val=hfx_fraction,error=error)

           WRITE(*,*) xc_fun%section%name, scale_x, hfx_fraction
        ELSE
          WRITE(*,*) xc_fun%section%name, scale_x
        END IF
      END DO

      WRITE(*,*) "auxiliary"
      xc_fun_section => section_vals_get_subs_vals(admm_env%xc_section_aux,"XC_FUNCTIONAL",error=error)
      ifun = 0
      funct_found = .FALSE.
      DO
        ifun = ifun+1
        xc_fun => section_vals_get_subs_vals2(xc_fun_section,i_section=ifun,error=error)
        IF (.NOT.ASSOCIATED(xc_fun)) EXIT
        scale_x=-1000.0_dp
        IF(xc_fun%section%name /= "LYP" .AND. xc_fun%section%name /= "VWN") THEN
          CALL section_vals_val_get(xc_fun,"SCALE_X",&
                                      r_val=scale_x,error=error)
        END IF
        IF( xc_fun%section%name == "XWPBE" ) THEN
          CALL section_vals_val_get(xc_fun,"SCALE_X0",&
                                    r_val=hfx_fraction,error=error)

           WRITE(*,*) xc_fun%section%name, scale_x, hfx_fraction
        ELSE
          WRITE(*,*) xc_fun%section%name, scale_x
        END IF
      END DO
    END IF

  END SUBROUTINE create_admm_xc_section

! *****************************************************************************
!> \brief ...
!> \param ispin ...
!> \param admm_env ...
!> \param mo_set ...
!> \param mo_coeff ...
!> \param mo_coeff_aux_fit ...
!> \param matrix_ks ...
!> \param matrix_ks_aux_fit ...
!> \param matrix_s ...
!> \param matrix_p_aux_fit ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE merge_ks_matrix_cauchy_subspace(ispin, admm_env, mo_set, mo_coeff, mo_coeff_aux_fit, &
                                             matrix_ks, matrix_ks_aux_fit, matrix_s, matrix_p_aux_fit, error)
    INTEGER, INTENT(IN)                      :: ispin
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(cp_fm_type), POINTER                :: mo_coeff, mo_coeff_aux_fit
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_ks, matrix_ks_aux_fit, &
                                                matrix_s, matrix_p_aux_fit
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: &
      routineN = 'merge_ks_matrix_cauchy_subspace', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, nao_aux_fit, nao_orb, &
                                                nmo
    INTEGER, SAVE                            :: counter = 0
    TYPE(cp_dbcsr_type), POINTER             :: matrix_k_tilde

    CALL timeset(routineN,handle)

    counter = counter + 1
    nao_aux_fit = admm_env%nao_aux_fit
    nao_orb = admm_env%nao_orb
    nmo = admm_env%nmo(ispin)

    !! Calculate Lambda^{-2}
    CALL cp_fm_to_fm(admm_env%lambda(ispin)%matrix, admm_env%work_nmo_nmo1(ispin)%matrix, error=error)
    CALL cp_fm_cholesky_decompose(admm_env%work_nmo_nmo1(ispin)%matrix,error=error)
    CALL cp_fm_cholesky_invert(admm_env%work_nmo_nmo1(ispin)%matrix,error=error)
    !! Symmetrize the guy
    CALL cp_fm_upper_to_full(admm_env%work_nmo_nmo1(ispin)%matrix,admm_env%lambda_inv2(ispin)%matrix,error=error)
    !! Take square
    CALL cp_gemm('N', 'T',  nmo, nmo, nmo,&
                    1.0_dp,admm_env%work_nmo_nmo1(ispin)%matrix,admm_env%work_nmo_nmo1(ispin)%matrix,0.0_dp,&
                    admm_env%lambda_inv2(ispin)%matrix,error)

    !! ** C_hat = AC
    CALL cp_gemm('N', 'N',  nao_aux_fit, nmo, nao_orb,&
                    1.0_dp,admm_env%A,mo_coeff,0.0_dp,&
                    admm_env%C_hat(ispin)%matrix,error)

    !! calc P_tilde from C_hat
    CALL cp_gemm('N', 'N',  nao_aux_fit, nmo, nmo,&
                    1.0_dp,admm_env%C_hat(ispin)%matrix,admm_env%lambda_inv(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_nmo(ispin)%matrix,error)

    CALL cp_gemm('N', 'T',  nao_aux_fit, nao_aux_fit, nmo,&
                    1.0_dp,admm_env%C_hat(ispin)%matrix,  admm_env%work_aux_nmo(ispin)%matrix,0.0_dp,&
                    admm_env%P_tilde(ispin)%matrix,error)


    !! ** C_hat*Lambda^{-2}
    CALL cp_gemm('N', 'N',  nao_aux_fit, nmo, nmo,&
                    1.0_dp,admm_env%C_hat(ispin)%matrix,admm_env%lambda_inv2(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_nmo(ispin)%matrix,error)

    !! ** C_hat*Lambda^{-2}*C_hat^T
    CALL cp_gemm('N', 'T',  nao_aux_fit, nao_aux_fit, nmo,&
                    1.0_dp,admm_env%work_aux_nmo(ispin)%matrix,admm_env%C_hat(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_aux,error)


    !! ** S*C_hat*Lambda^{-2}*C_hat^T
    CALL cp_gemm('N', 'N',  nao_aux_fit, nao_aux_fit, nao_aux_fit,&
                    1.0_dp,admm_env%S,admm_env%work_aux_aux,0.0_dp,&
                    admm_env%work_aux_aux2,error)


    CALL copy_dbcsr_to_fm(matrix_ks_aux_fit(ispin)%matrix,admm_env%K(ispin)%matrix,error)
    CALL cp_fm_upper_to_full(admm_env%K(ispin)%matrix,admm_env%work_aux_aux,error=error)

    !! ** S*C_hat*Lambda^{-2}*C_hat^T*H_tilde
    CALL cp_gemm('N', 'N',  nao_aux_fit, nao_aux_fit, nao_aux_fit,&
                    1.0_dp,admm_env%work_aux_aux2,admm_env%K(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_aux,error)

    !! ** P_tilde*S
    CALL cp_gemm('N', 'N',  nao_aux_fit, nao_aux_fit, nao_aux_fit,&
                    1.0_dp,admm_env%P_tilde(ispin)%matrix,admm_env%S,0.0_dp,&
                    admm_env%work_aux_aux2,error)


    !! ** -S*C_hat*Lambda^{-2}*C_hat^T*H_tilde*P_tilde*S
    CALL cp_gemm('N', 'N',  nao_aux_fit, nao_aux_fit, nao_aux_fit,&
                    -1.0_dp,admm_env%work_aux_aux,admm_env%work_aux_aux2,0.0_dp,&
                    admm_env%work_aux_aux3,error)


    !! ** -S*C_hat*Lambda^{-2}*C_hat^T*H_tilde*P_tilde*S+S*C_hat*Lambda^{-2}*C_hat^T*H_tilde
    CALL cp_fm_scale_and_add(1.0_dp,admm_env%work_aux_aux3,1.0_dp,admm_env%work_aux_aux,error)


    !! first_part*A
    CALL cp_gemm('N', 'N',  nao_aux_fit, nao_orb, nao_aux_fit,&
                    1.0_dp,admm_env%work_aux_aux3,admm_env%A,0.0_dp,&
                    admm_env%work_aux_orb,error)

    !! + first_part^T*A
    CALL cp_gemm('T', 'N',  nao_aux_fit, nao_orb, nao_aux_fit,&
                    1.0_dp,admm_env%work_aux_aux3,admm_env%A,1.0_dp,&
                    admm_env%work_aux_orb,error)



    !! A^T*(first+seccond)=H
    CALL cp_gemm('T', 'N',  nao_orb, nao_orb, nao_aux_fit,&
                    1.0_dp,admm_env%A,admm_env%work_aux_orb,0.0_dp,&
                    admm_env%work_orb_orb,error)


    NULLIFY(matrix_k_tilde)
    ALLOCATE(matrix_k_tilde)
    CALL cp_dbcsr_init (matrix_k_tilde, error)
    CALL cp_dbcsr_create(matrix_k_tilde, 'MATRIX K_tilde', &
         cp_dbcsr_distribution(matrix_ks(ispin)%matrix), dbcsr_type_symmetric, cp_dbcsr_row_block_sizes(matrix_ks(ispin)%matrix),&
         cp_dbcsr_col_block_sizes(matrix_ks(ispin)%matrix), &
         cp_dbcsr_get_num_blocks(matrix_ks(ispin)%matrix), &
         cp_dbcsr_get_data_size(matrix_ks(ispin)%matrix),&
         cp_dbcsr_get_data_type(matrix_ks(ispin)%matrix), error=error)


    CALL cp_fm_to_fm(admm_env%work_orb_orb, admm_env%ks_to_be_merged(ispin)%matrix, error=error)

    CALL cp_dbcsr_copy(matrix_k_tilde, matrix_ks(ispin)%matrix, error=error)
    CALL cp_dbcsr_set(matrix_k_tilde, 0.0_dp, error)
    CALL copy_fm_to_dbcsr(admm_env%work_orb_orb, matrix_k_tilde, keep_sparsity=.TRUE.,&
         error=error)

    CALL cp_gemm('N', 'N',  nao_orb, nmo, nao_orb,&
                    1.0_dp,admm_env%work_orb_orb,mo_coeff,0.0_dp,&
                    admm_env%mo_derivs_tmp(ispin)%matrix,error)


    CALL cp_dbcsr_add(matrix_ks(ispin)%matrix, matrix_k_tilde, 1.0_dp, 1.0_dp, error)

    CALL cp_dbcsr_deallocate_matrix(matrix_k_tilde,error)

    CALL timestop(handle)

  END SUBROUTINE merge_ks_matrix_cauchy_subspace

! *****************************************************************************
!> \brief ...
!> \param ispin ...
!> \param admm_env ...
!> \param mo_set ...
!> \param mo_coeff ...
!> \param mo_coeff_aux_fit ...
!> \param matrix_ks ...
!> \param matrix_ks_aux_fit ...
!> \param matrix_s ...
!> \param matrix_p_aux_fit ...
!> \param blocked ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE merge_ks_matrix_none(ispin, admm_env, mo_set, mo_coeff, mo_coeff_aux_fit, &
                                  matrix_ks, matrix_ks_aux_fit, matrix_s, matrix_p_aux_fit, blocked, error)
    INTEGER, INTENT(IN)                      :: ispin
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(cp_fm_type), POINTER                :: mo_coeff, mo_coeff_aux_fit
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_ks, matrix_ks_aux_fit, &
                                                matrix_s, matrix_p_aux_fit
    LOGICAL                                  :: blocked
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'merge_ks_matrix_none', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: blk, handle, iatom, jatom, &
                                                nao_aux_fit, nao_orb, nmo
    INTEGER, SAVE                            :: counter = 0
    REAL(dp), DIMENSION(:, :), POINTER       :: sparse_block
    TYPE(cp_dbcsr_iterator)                  :: iter
    TYPE(cp_dbcsr_type), POINTER             :: matrix_k_tilde

    CALL timeset(routineN,handle)

    IF(blocked) THEN
       CALL cp_dbcsr_iterator_start(iter, matrix_ks_aux_fit(ispin)%matrix)
       DO WHILE (cp_dbcsr_iterator_blocks_left (iter))
         CALL cp_dbcsr_iterator_next_block(iter, iatom, jatom, sparse_block, blk)
         IF( admm_env%block_map(iatom,jatom) == 0 ) THEN
           sparse_block = 0.0_dp
         END IF
       END DO
       CALL cp_dbcsr_iterator_stop(iter)
       CALL cp_dbcsr_add(matrix_ks(ispin)%matrix, matrix_ks_aux_fit(ispin)%matrix, 1.0_dp, 1.0_dp, error)

    ELSE

       counter = counter + 1
       nao_aux_fit = admm_env%nao_aux_fit
       nao_orb = admm_env%nao_orb
       nmo = admm_env%nmo(ispin)
       CALL copy_dbcsr_to_fm(matrix_ks_aux_fit(ispin)%matrix,admm_env%K(ispin)%matrix,error)
       CALL cp_fm_upper_to_full(admm_env%K(ispin)%matrix,admm_env%work_aux_aux,error=error)

       !! K*A
       CALL cp_gemm('N', 'N',  nao_aux_fit, nao_orb, nao_aux_fit,&
                       1.0_dp,admm_env%K(ispin)%matrix,admm_env%A,0.0_dp,&
                       admm_env%work_aux_orb,error)
       !! A^T*K*A
       CALL cp_gemm('T', 'N',  nao_orb, nao_orb, nao_aux_fit,&
                       1.0_dp,admm_env%A,admm_env%work_aux_orb,0.0_dp,&
                       admm_env%work_orb_orb,error)


       NULLIFY(matrix_k_tilde)
       ALLOCATE(matrix_k_tilde)
       CALL cp_dbcsr_init (matrix_k_tilde, error)
       CALL cp_dbcsr_create(matrix_k_tilde,template=matrix_ks(ispin)%matrix,&
                            name='MATRIX K_tilde', matrix_type='S', error=error)
       CALL cp_dbcsr_copy(matrix_k_tilde, matrix_ks(ispin)%matrix, error=error)
       CALL cp_dbcsr_set(matrix_k_tilde, 0.0_dp, error)
       CALL copy_fm_to_dbcsr(admm_env%work_orb_orb, matrix_k_tilde, keep_sparsity=.TRUE.,&
            error=error)

       CALL cp_dbcsr_add(matrix_ks(ispin)%matrix, matrix_k_tilde, 1.0_dp, 1.0_dp, error)

       CALL cp_dbcsr_deallocate_matrix(matrix_k_tilde,error)
    ENDIF
    CALL timestop(handle)

  END SUBROUTINE merge_ks_matrix_none


! *****************************************************************************
!> \brief Merge auxilary KS-matrix into the primary one using reverse McWeeny
!> \param matrix_ks ...
!> \param matrix_ks_aux_fit ...
!> \param matrix_s_aux_fit ...
!> \param matrix_A ...
!> \param history Intermentiate matrices created during McWeeny purficiation.
!> \param threshold ...
!> \param error ...
!> \author Ole Schuett
! *****************************************************************************
  SUBROUTINE merge_ks_matrix_mcweeny(matrix_ks, matrix_ks_aux_fit, matrix_s_aux_fit,&
                                     matrix_A, history, threshold, error)
    TYPE(cp_dbcsr_type), INTENT(INOUT)       :: matrix_ks
    TYPE(cp_dbcsr_type), INTENT(IN)          :: matrix_ks_aux_fit, &
                                                matrix_s_aux_fit, matrix_A
    TYPE(mcweeny_history_type), POINTER      :: history
    REAL(KIND=dp), INTENT(IN)                :: threshold
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'merge_ks_matrix_mcweeny', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, unit_nr
    TYPE(cp_dbcsr_type)                      :: matrix_K, matrix_KA
    TYPE(mcweeny_history_type), POINTER      :: history_curr, history_next

    CALL timeset(routineN,handle)
    NULLIFY(history_next, history_curr)
    unit_nr = cp_logger_get_default_unit_nr()
    history_curr => history
    NULLIFY(history)
    CALL cp_dbcsr_init(matrix_K, error=error)
    CALL cp_dbcsr_copy(matrix_K, matrix_ks_aux_fit, name="K", error=error)

    ! reverse McWeeny iteration
    DO WHILE (ASSOCIATED(history_curr))
       IF(unit_nr>1) WRITE(unit_nr,'(t3,a,i5)')"Reverse McWeeny-Step ", history_curr%count
       CALL reverse_mcweeny(matrix_k=matrix_k,&
                            matrix_s=matrix_s_aux_fit,&
                            matrix_p=history_curr%m,&
                            threshold=threshold,&
                            error=error)
       CALL cp_dbcsr_release(history_curr%m,error)
       history_next => history_curr%next
       DEALLOCATE(history_curr)
       history_curr => history_next
       NULLIFY(history_next)
    END DO

    ! Add contribution to primary Kohn-Sham matrix
    ! matrix_ks += A^T * K * A
    CALL cp_dbcsr_init(matrix_KA,error=error)
    CALL cp_dbcsr_create(matrix_KA,template=matrix_A, matrix_type="N",error=error)
    CALL cp_dbcsr_multiply("N", "N", 1.0_dp, matrix_K, matrix_A, &
                           0.0_dp, matrix_KA, filter_eps=threshold, error=error)
    CALL cp_dbcsr_multiply("T", "N", 1.0_dp, matrix_A, matrix_KA, &
                           1.0_dp, matrix_ks, filter_eps=threshold, error=error)

    ! clean up
    CALL cp_dbcsr_release(matrix_KA, error=error)
    CALL cp_dbcsr_release(matrix_K, error=error)
    CALL timestop(handle)

  END SUBROUTINE merge_ks_matrix_mcweeny


! *****************************************************************************
!> \brief Multiply matrix_k with partial derivative of McWeeny by reversing it.
!> \param matrix_k ...
!> \param matrix_s ...
!> \param matrix_p ...
!> \param threshold ...
!> \param error ...
!> \author Ole Schuett
! *****************************************************************************
  SUBROUTINE reverse_mcweeny(matrix_k, matrix_s, matrix_p, threshold, error)
    TYPE(cp_dbcsr_type)                      :: matrix_k, matrix_s, matrix_p
    REAL(KIND=dp), INTENT(IN)                :: threshold
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'reverse_mcweeny', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle
    TYPE(cp_dbcsr_type)                      :: matrix_ps, matrix_sp, &
                                                matrix_sum, matrix_tmp

    CALL timeset(routineN,handle)
    CALL cp_dbcsr_init(matrix_ps,error=error)
    CALL cp_dbcsr_create(matrix_ps,template=matrix_p,matrix_type="N",error=error)
    CALL cp_dbcsr_init(matrix_sp,error=error)
    CALL cp_dbcsr_create(matrix_sp,template=matrix_p,matrix_type="N",error=error)
    CALL cp_dbcsr_init(matrix_tmp,error=error)
    CALL cp_dbcsr_create(matrix_tmp,template=matrix_p,matrix_type="N",error=error)
    CALL cp_dbcsr_init(matrix_sum,error=error)
    CALL cp_dbcsr_create(matrix_sum,template=matrix_p,matrix_type="N",error=error)

    CALL cp_dbcsr_multiply("N", "N", 1.0_dp, matrix_p, matrix_s,&
             0.0_dp, matrix_ps, filter_eps=threshold, error=error)
    CALL cp_dbcsr_multiply("N", "N", 1.0_dp, matrix_s, matrix_p,&
             0.0_dp, matrix_sp, filter_eps=threshold, error=error)

    !TODO: can we exploid more symmetry?
    CALL cp_dbcsr_multiply("N", "N", 3.0_dp, matrix_k, matrix_ps,&
             0.0_dp, matrix_sum, filter_eps=threshold, error=error)
    CALL cp_dbcsr_multiply("N", "N", 3.0_dp, matrix_sp, matrix_k,&
             1.0_dp, matrix_sum, filter_eps=threshold, error=error)

    !matrix_tmp = KPS
    CALL cp_dbcsr_multiply("N", "N", 1.0_dp, matrix_k, matrix_ps,&
             0.0_dp, matrix_tmp, filter_eps=threshold, error=error)
    CALL cp_dbcsr_multiply("N", "N", -2.0_dp, matrix_tmp, matrix_ps,&
            1.0_dp, matrix_sum, filter_eps=threshold, error=error)
    CALL cp_dbcsr_multiply("N", "N", -2.0_dp, matrix_sp, matrix_tmp,&
            1.0_dp, matrix_sum, filter_eps=threshold, error=error)

    !matrix_tmp = SPK
    CALL cp_dbcsr_multiply("N", "N", 1.0_dp, matrix_sp, matrix_k,&
             0.0_dp, matrix_tmp, filter_eps=threshold, error=error)
    CALL cp_dbcsr_multiply("N", "N", -2.0_dp, matrix_sp, matrix_tmp,&
            1.0_dp, matrix_sum, filter_eps=threshold, error=error)

    ! overwrite matrix_k
    CALL cp_dbcsr_copy(matrix_k, matrix_sum, name="K from reverse McWeeny", error=error)

    ! clean up
    CALL cp_dbcsr_release(matrix_sum,error)
    CALL cp_dbcsr_release(matrix_tmp,error)
    CALL cp_dbcsr_release(matrix_ps,error)
    CALL cp_dbcsr_release(matrix_sp,error)
    CALL timestop(handle)
  END SUBROUTINE reverse_mcweeny


! *****************************************************************************
!> \brief ...
!> \param admm_env ...
!> \param mo_set ...
!> \param density_matrix ...
!> \param ispin ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE calculate_dm_mo_no_diag(admm_env,mo_set,density_matrix,ispin,error)
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(cp_dbcsr_type), POINTER             :: density_matrix
    INTEGER                                  :: ispin
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'calculate_dm_mo_no_diag', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, nao_aux_fit, nmo
    REAL(KIND=dp)                            :: alpha

    CALL timeset(routineN,handle)


    CALL cp_dbcsr_set(density_matrix,0.0_dp,error=error)
    nao_aux_fit = admm_env%nao_aux_fit
    nmo = admm_env%nmo(ispin)
    CALL cp_fm_to_fm(admm_env%C_hat(ispin)%matrix, admm_env%work_aux_nmo(ispin)%matrix, error=error)
    CALL cp_fm_column_scale(admm_env%work_aux_nmo(ispin)%matrix,mo_set%occupation_numbers(1:mo_set%homo))

    CALL cp_gemm('N','N',nao_aux_fit,nmo,nmo,&
                    1.0_dp,admm_env%work_aux_nmo(ispin)%matrix,admm_env%lambda_inv(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_nmo2(ispin)%matrix,error)


    IF ( .NOT. mo_set%uniform_occupation ) THEN ! not all orbitals 1..homo are equally occupied
      alpha=1.0_dp
      CALL cp_dbcsr_plus_fm_fm_t(sparse_matrix=density_matrix,&
                              matrix_v=admm_env%C_hat(ispin)%matrix,&
                              matrix_g=admm_env%work_aux_nmo2(ispin)%matrix,&
                              ncol=mo_set%homo,&
                              alpha=alpha,error=error)
    ELSE
      alpha=1.0_dp
      !alpha=mo_set%maxocc
      CALL cp_dbcsr_plus_fm_fm_t(sparse_matrix=density_matrix,&
                              matrix_v=admm_env%C_hat(ispin)%matrix,&
                              matrix_g=admm_env%work_aux_nmo2(ispin)%matrix,&
                              ncol=mo_set%homo,&
                              alpha=alpha,error=error)
    ENDIF

    CALL timestop(handle)

  END SUBROUTINE calculate_dm_mo_no_diag

! *****************************************************************************
!> \brief ...
!> \param admm_env ...
!> \param mo_set ...
!> \param density_matrix ...
!> \param ispin ...
!> \param blocked ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE purify_dm_cauchy(admm_env,mo_set,density_matrix,ispin,blocked,error)

    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(cp_dbcsr_type), POINTER             :: density_matrix
    INTEGER                                  :: ispin
    LOGICAL, INTENT(IN)                      :: blocked
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'purify_dm_cauchy', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, i, nao_aux_fit, &
                                                nao_orb, nmo, nspins
    REAL(KIND=dp)                            :: pole
    TYPE(cp_fm_type), POINTER                :: mo_coeff_aux_fit

    CALL timeset(routineN,handle)

    nao_aux_fit = admm_env%nao_aux_fit
    nao_orb = admm_env%nao_orb
    nmo = admm_env%nmo(ispin)

    nspins = SIZE(admm_env%P_to_be_purified)

    CALL get_mo_set(mo_set=mo_set, mo_coeff=mo_coeff_aux_fit)

    !! * For the time beeing, get the P to be purified from the mo_coeffs
    !! * This needs to be replaced with the a block modified P

    IF(.NOT. blocked) THEN
       CALL cp_gemm('N','T',nao_aux_fit,nao_aux_fit,nmo,&
                     1.0_dp,mo_coeff_aux_fit,mo_coeff_aux_fit,0.0_dp,&
                     admm_env%P_to_be_purified(ispin)%matrix,error)
    ENDIF

    CALL cp_fm_to_fm(admm_env%S, admm_env%work_aux_aux, error=error)
    CALL cp_fm_to_fm(admm_env%P_to_be_purified(ispin)%matrix, admm_env%work_aux_aux2, error=error)

    CALL cp_fm_cholesky_decompose(admm_env%work_aux_aux,error=error)

    CALL cp_fm_cholesky_reduce(admm_env%work_aux_aux2, admm_env%work_aux_aux, itype=3, error=error)

    CALL cp_fm_syevd(admm_env%work_aux_aux2,admm_env%R_purify(ispin)%matrix,&
                     admm_env%eigvals_P_to_be_purified(ispin)%eigvals%data,error=error)

    CALL cp_fm_cholesky_restore(admm_env%R_purify(ispin)%matrix, nao_aux_fit,admm_env%work_aux_aux, &
                                admm_env%work_aux_aux3,op="MULTIPLY",pos="LEFT", transa="T", error=error)

    CALL cp_fm_to_fm(admm_env%work_aux_aux3, admm_env%R_purify(ispin)%matrix, error=error)

    ! *** Construct Matrix M for Hadamard Product
    CALL cp_fm_set_all(admm_env%M_purify(ispin)%matrix,0.0_dp,error=error)
    pole = 0.0_dp
    DO i=1,nao_aux_fit
      pole = Heaviside(admm_env%eigvals_P_to_be_purified(ispin)%eigvals%data(i)-0.5_dp)
      CALL cp_fm_set_element(admm_env%M_purify(ispin)%matrix,i,i,pole,error)
    END DO
    CALL cp_fm_upper_to_full(admm_env%M_purify(ispin)%matrix,admm_env%work_aux_aux,error=error)

    CALL copy_dbcsr_to_fm(density_matrix,admm_env%work_aux_aux3,error)
    CALL cp_fm_upper_to_full(admm_env%work_aux_aux3,admm_env%work_aux_aux,error=error)

    ! ** S^(-1)*R
    CALL cp_gemm('N','N',nao_aux_fit,nao_aux_fit,nao_aux_fit,&
                    1.0_dp,admm_env%S_inv,admm_env%R_purify(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_aux,error)
    ! ** S^(-1)*R*M
    CALL cp_gemm('N','N',nao_aux_fit,nao_aux_fit,nao_aux_fit,&
                    1.0_dp,admm_env%work_aux_aux,admm_env%M_purify(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_aux2,error)
    ! ** S^(-1)*R*M*R^T*S^(-1)
    CALL cp_gemm('N','T',nao_aux_fit,nao_aux_fit,nao_aux_fit,&
                    1.0_dp,admm_env%work_aux_aux2,admm_env%work_aux_aux,0.0_dp,&
                    admm_env%work_aux_aux3,error)

    CALL copy_fm_to_dbcsr(admm_env%work_aux_aux3, density_matrix,keep_sparsity=.TRUE., error=error)

    IF( nspins == 1 ) THEN
      CALL cp_dbcsr_scale(density_matrix, 2.0_dp, error=error)
    END IF

    CALL timestop(handle)

  END SUBROUTINE purify_dm_cauchy


! *****************************************************************************
!> \brief Apply McWeeny purification to matrix_p.
!> \param matrix_p ...
!> \param matrix_s ...
!> \param history stores intermentiate matrices, needed later by reverse_mcweeny.
!> \param threshold ...
!> \param max_steps ...
!> \param error ...
!> \author Ole Schuett
! *****************************************************************************
  SUBROUTINE purify_dm_mcweeny(matrix_p, matrix_s, history, threshold, max_steps, error)
    TYPE(cp_dbcsr_type), INTENT(INOUT)       :: matrix_p
    TYPE(cp_dbcsr_type), INTENT(IN)          :: matrix_s
    TYPE(mcweeny_history_type), POINTER      :: history
    REAL(KIND=dp), INTENT(IN)                :: threshold
    INTEGER, INTENT(IN)                      :: max_steps
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'purify_dm_mcweeny', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, i, unit_nr
    REAL(KIND=dp)                            :: frob_norm
    TYPE(cp_dbcsr_type)                      :: matrix_ps, matrix_psp, &
                                                matrix_test
    TYPE(mcweeny_history_type), POINTER      :: new_hist_entry

    IF(ASSOCIATED(history)) STOP "purify_dm_mcweeny: history already associated"
    NULLIFY(new_hist_entry)

    CALL timeset(routineN,handle)
    unit_nr = cp_logger_get_default_unit_nr()
    CALL cp_dbcsr_init(matrix_PS,error=error)
    CALL cp_dbcsr_create(matrix_PS,template=matrix_p,matrix_type="N",error=error)
    CALL cp_dbcsr_init(matrix_PSP,error=error)
    CALL cp_dbcsr_create(matrix_PSP,template=matrix_p,matrix_type="S",error=error)
    CALL cp_dbcsr_init(matrix_test,error=error)
    CALL cp_dbcsr_create(matrix_test,template=matrix_p,matrix_type="S",error=error)

    DO i=1, max_steps
       ! allocate new element in linked list
        ALLOCATE(new_hist_entry)
        new_hist_entry%next => history
        history => new_hist_entry
        history%count = i
        NULLIFY(new_hist_entry)
        CALL cp_dbcsr_init(history%m, error=error)
        CALL cp_dbcsr_create(history%m, template=matrix_p ,matrix_type="N",error=error)
        CALL cp_dbcsr_copy(history%m, matrix_p, name="P from McWeeny", error=error)

        ! calc PS and PSP
        CALL cp_dbcsr_multiply("N", "N", 1.0_dp, matrix_p, matrix_s,&
             0.0_dp, matrix_ps, filter_eps=threshold,error=error)

        CALL cp_dbcsr_multiply("N", "N", 1.0_dp, matrix_ps, matrix_p,&
             0.0_dp, matrix_psp, filter_eps=threshold,error=error)

        !test convergence
        CALL cp_dbcsr_copy(matrix_test, matrix_psp, error=error)
        CALL cp_dbcsr_add(matrix_test, matrix_p, 1.0_dp,-1.0_dp,error=error)
        frob_norm=cp_dbcsr_frobenius_norm(matrix_test)
        IF(unit_nr>0) WRITE(unit_nr,'(t3,a,i5,a,f16.8)')"McWeeny-Step",i,": Deviation of idempotency",frob_norm
        IF(frob_norm < 1000_dp*threshold .AND. i>1) EXIT

        ! build next P matrix
        CALL cp_dbcsr_copy(matrix_p, matrix_PSP, name="P from McWeeny", error=error)
        CALL cp_dbcsr_multiply("N", "N", -2.0_dp, matrix_PS, matrix_PSP,&
             3.0_dp, matrix_p, filter_eps=threshold, error=error)
    END DO

    ! clean up
    CALL cp_dbcsr_release(matrix_PS,error)
    CALL cp_dbcsr_release(matrix_PSP,error)
    CALL cp_dbcsr_release(matrix_test,error)
    CALL timestop(handle)
  END SUBROUTINE purify_dm_mcweeny


! *****************************************************************************
!> \brief ...
!> \param admm_env ...
!> \param density_matrix ...
!> \param density_matrix_aux ...
!> \param ispin ...
!> \param nspins ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE blockify_density_matrix(admm_env,density_matrix, density_matrix_aux,&
                                     ispin, nspins, error)
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(cp_dbcsr_type), POINTER             :: density_matrix, &
                                                density_matrix_aux
    INTEGER                                  :: ispin, nspins
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'blockify_density_matrix', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: blk, handle, iatom, jatom
    LOGICAL                                  :: found
    REAL(dp), DIMENSION(:, :), POINTER       :: sparse_block, sparse_block_aux
    TYPE(cp_dbcsr_iterator)                  :: iter

    CALL timeset(routineN,handle)

    ! ** set blocked density matrix to 0
    CALL cp_dbcsr_set(density_matrix_aux, 0.0_dp, error)

    ! ** now loop through the list and copy corresponding blocks
    CALL cp_dbcsr_iterator_start(iter, density_matrix)
    DO WHILE (cp_dbcsr_iterator_blocks_left (iter))
      CALL cp_dbcsr_iterator_next_block(iter, iatom, jatom, sparse_block, blk)
      IF( admm_env%block_map(iatom,jatom) == 1 ) THEN
        CALL cp_dbcsr_get_block_p(density_matrix_aux,&
                               row=iatom,col=jatom,BLOCK=sparse_block_aux,found=found)
        IF( found ) THEN
          sparse_block_aux = sparse_block
        END IF

      END IF
    END DO
    CALL cp_dbcsr_iterator_stop(iter)

    CALL copy_dbcsr_to_fm(density_matrix_aux,admm_env%P_to_be_purified(ispin)%matrix,error)
    CALL cp_fm_upper_to_full(admm_env%P_to_be_purified(ispin)%matrix, admm_env%work_orb_orb2,error=error)

    IF( nspins == 1 ) THEN
      CALL cp_fm_scale(0.5_dp, admm_env%P_to_be_purified(ispin)%matrix, error)
    END IF

    CALL timestop(handle)
  END SUBROUTINE blockify_density_matrix

! *****************************************************************************
!> \brief ...
!> \param ispin ...
!> \param admm_env ...
!> \param mo_set ...
!> \param mo_coeff ...
!> \param mo_coeff_aux_fit ...
!> \param matrix_ks ...
!> \param matrix_ks_aux_fit ...
!> \param matrix_s ...
!> \param matrix_p_aux_fit ...
!> \param matrix_p ...
!> \param blocked ...
!> \param error ...
! *****************************************************************************
  SUBROUTINE merge_ks_matrix_cauchy(ispin, admm_env, mo_set, mo_coeff, mo_coeff_aux_fit, &
                                    matrix_ks, matrix_ks_aux_fit, matrix_s, matrix_p_aux_fit,&
                                    matrix_p, blocked, error)
    INTEGER, INTENT(IN)                      :: ispin
    TYPE(admm_type), POINTER                 :: admm_env
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(cp_fm_type), POINTER                :: mo_coeff, mo_coeff_aux_fit
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_ks, matrix_ks_aux_fit, &
                                                matrix_s, matrix_p_aux_fit, &
                                                matrix_p
    LOGICAL, INTENT(IN)                      :: blocked
    TYPE(cp_error_type), INTENT(INOUT)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'merge_ks_matrix_cauchy', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: blk, handle, i, iatom, j, &
                                                jatom, nao_aux_fit, nao_orb, &
                                                nmo, nspins
    REAL(dp)                                 :: eig_diff, pole, tmp
    REAL(dp), DIMENSION(:, :), POINTER       :: sparse_block
    TYPE(cp_dbcsr_iterator)                  :: iter
    TYPE(cp_dbcsr_type), POINTER             :: matrix_k_tilde

    CALL timeset(routineN,handle)

    nao_aux_fit = admm_env%nao_aux_fit
    nao_orb = admm_env%nao_orb
    nmo = admm_env%nmo(ispin)
    nspins = SIZE(admm_env%P_to_be_purified)

    IF(.NOT. blocked) THEN
       !** Get P from mo_coeffs, otherwise we have troubles with occupation numbers ...
       CALL cp_gemm('N', 'T',  nao_orb, nao_orb, nmo,&
                       1.0_dp, mo_coeff, mo_coeff, 0.0_dp,&
                       admm_env%work_orb_orb,error)

       !! A*P
       CALL cp_gemm('N', 'N',  nao_aux_fit, nao_orb, nao_orb,&
                       1.0_dp, admm_env%A, admm_env%work_orb_orb, 0.0_dp,&
                       admm_env%work_aux_orb2,error)
       !! A*P*A^T
       CALL cp_gemm('N', 'T',  nao_aux_fit, nao_aux_fit, nao_orb,&
                       1.0_dp, admm_env%work_aux_orb2, admm_env%A, 0.0_dp,&
                       admm_env%P_to_be_purified(ispin)%matrix,error)

    ENDIF

    CALL cp_fm_to_fm(admm_env%S, admm_env%work_aux_aux, error=error)
    CALL cp_fm_to_fm(admm_env%P_to_be_purified(ispin)%matrix, admm_env%work_aux_aux2, error=error)

    CALL cp_fm_cholesky_decompose(admm_env%work_aux_aux,error=error)

    CALL cp_fm_cholesky_reduce(admm_env%work_aux_aux2, admm_env%work_aux_aux, itype=3, error=error)

    CALL cp_fm_syevd(admm_env%work_aux_aux2,admm_env%R_purify(ispin)%matrix,&
                     admm_env%eigvals_P_to_be_purified(ispin)%eigvals%data,error=error)

    CALL cp_fm_cholesky_restore(admm_env%R_purify(ispin)%matrix, nao_aux_fit,admm_env%work_aux_aux, &
                                admm_env%work_aux_aux3,op="MULTIPLY",pos="LEFT", transa="T", error=error)

    CALL cp_fm_to_fm(admm_env%work_aux_aux3, admm_env%R_purify(ispin)%matrix, error=error)

    ! *** Construct Matrix M for Hadamard Product
    pole = 0.0_dp
    DO i=1,nao_aux_fit
      DO j=i,nao_aux_fit
        eig_diff = ( admm_env%eigvals_P_to_be_purified(ispin)%eigvals%data(i) -&
                     admm_env%eigvals_P_to_be_purified(ispin)%eigvals%data(j) )
        ! *** two eigenvalues could be the degenerated. In that case use 2nd order formula for the poles
        IF( ABS(eig_diff) == 0.0_dp ) THEN
          pole = delta(admm_env%eigvals_P_to_be_purified(ispin)%eigvals%data(i)-0.5_dp)
          CALL cp_fm_set_element(admm_env%M_purify(ispin)%matrix,i,j,pole,error)
        ELSE
          pole = 1.0_dp/(admm_env%eigvals_P_to_be_purified(ispin)%eigvals%data(i)-&
                         admm_env%eigvals_P_to_be_purified(ispin)%eigvals%data(j))
          tmp = Heaviside(admm_env%eigvals_P_to_be_purified(ispin)%eigvals%data(i)-0.5_dp)
          tmp = tmp - Heaviside(admm_env%eigvals_P_to_be_purified(ispin)%eigvals%data(j)-0.5_dp)
          pole = tmp*pole
          CALL cp_fm_set_element(admm_env%M_purify(ispin)%matrix,i,j,pole,error)
        END IF
      END DO
    END DO
    CALL cp_fm_upper_to_full(admm_env%M_purify(ispin)%matrix,admm_env%work_aux_aux,error=error)

    CALL copy_dbcsr_to_fm(matrix_ks_aux_fit(ispin)%matrix,admm_env%K(ispin)%matrix,error)
    CALL cp_fm_upper_to_full(admm_env%K(ispin)%matrix,admm_env%work_aux_aux,error=error)


    !! S^(-1)*R
    CALL cp_gemm('N', 'N',  nao_aux_fit, nao_aux_fit, nao_aux_fit,&
                    1.0_dp,admm_env%S_inv,admm_env%R_purify(ispin)%matrix,0.0_dp,&
                    admm_env%work_aux_aux,error)
    !! K*S^(-1)*R
    CALL cp_gemm('N', 'N',  nao_aux_fit, nao_aux_fit, nao_aux_fit,&
                    1.0_dp,admm_env%K(ispin)%matrix,admm_env%work_aux_aux,0.0_dp,&
                    admm_env%work_aux_aux2,error)
    !! R^T*S^(-1)*K*S^(-1)*R
    CALL cp_gemm('T', 'N',  nao_aux_fit, nao_aux_fit, nao_aux_fit,&
                    1.0_dp,admm_env%work_aux_aux,admm_env%work_aux_aux2,0.0_dp,&
                    admm_env%work_aux_aux3,error)
    !! R^T*S^(-1)*K*S^(-1)*R x M
    CALL cp_fm_schur_product(admm_env%work_aux_aux3, admm_env%M_purify(ispin)%matrix,&
                             admm_env%work_aux_aux,error)

    !! R^T*A
    CALL cp_gemm('T', 'N',  nao_aux_fit, nao_orb, nao_aux_fit,&
                    1.0_dp, admm_env%R_purify(ispin)%matrix, admm_env%A, 0.0_dp,&
                    admm_env%work_aux_orb,error)

    !! (R^T*S^(-1)*K*S^(-1)*R x M) * R^T*A
    CALL cp_gemm('N', 'N',  nao_aux_fit, nao_orb, nao_aux_fit,&
                    1.0_dp, admm_env%work_aux_aux, admm_env%work_aux_orb, 0.0_dp,&
                    admm_env%work_aux_orb2,error)
    !! A^T*R*(R^T*S^(-1)*K*S^(-1)*R x M) * R^T*A
    CALL cp_gemm('T', 'N',  nao_orb, nao_orb, nao_aux_fit,&
                    1.0_dp, admm_env%work_aux_orb, admm_env%work_aux_orb2, 0.0_dp,&
                    admm_env%work_orb_orb,error)


    NULLIFY(matrix_k_tilde)
    ALLOCATE(matrix_k_tilde)
    CALL cp_dbcsr_init (matrix_k_tilde, error)
    CALL cp_dbcsr_create(matrix_k_tilde, 'MATRIX K_tilde', &
         cp_dbcsr_distribution(matrix_ks(ispin)%matrix), dbcsr_type_symmetric, cp_dbcsr_row_block_sizes(matrix_ks(ispin)%matrix),&
         cp_dbcsr_col_block_sizes(matrix_ks(ispin)%matrix), cp_dbcsr_get_num_blocks(matrix_ks(ispin)%matrix),&
         cp_dbcsr_get_data_size( matrix_ks(ispin)%matrix),&
         cp_dbcsr_get_data_type(matrix_ks(ispin)%matrix), error=error)

    CALL cp_fm_to_fm(admm_env%work_orb_orb, admm_env%ks_to_be_merged(ispin)%matrix, error=error)

    CALL cp_dbcsr_copy(matrix_k_tilde, matrix_ks(ispin)%matrix, error=error)
    CALL cp_dbcsr_set(matrix_k_tilde, 0.0_dp, error)
    CALL copy_fm_to_dbcsr(admm_env%work_orb_orb, matrix_k_tilde, keep_sparsity=.TRUE., error=error)

    IF(blocked) THEN
       ! ** now loop through the list and nullify blocks
       CALL cp_dbcsr_iterator_start(iter, matrix_k_tilde)
       DO WHILE (cp_dbcsr_iterator_blocks_left (iter))
         CALL cp_dbcsr_iterator_next_block(iter, iatom, jatom, sparse_block, blk)
         IF( admm_env%block_map(iatom,jatom) == 0 ) THEN
            sparse_block = 0.0_dp
         END IF
       END DO
       CALL cp_dbcsr_iterator_stop(iter)
    ENDIF

    CALL cp_dbcsr_add(matrix_ks(ispin)%matrix, matrix_k_tilde, 1.0_dp, 1.0_dp, error)

    CALL cp_dbcsr_deallocate_matrix(matrix_k_tilde,error)

    CALL timestop(handle)

  END SUBROUTINE merge_ks_matrix_cauchy

! *****************************************************************************
!> \brief ...
!> \param x ...
! *****************************************************************************
  FUNCTION delta(x)
    REAL(KIND=dp), INTENT(IN)                :: x
    REAL(KIND=dp)                            :: delta

    IF( x == 0.0_dp) THEN !TODO: exact comparison of reals?
      delta = 1.0_dp
    ELSE
      delta = 0.0_dp
    END IF

  END FUNCTION delta

! *****************************************************************************
!> \brief ...
!> \param x ...
! *****************************************************************************
  FUNCTION Heaviside(x)
    REAL(KIND=dp), INTENT(IN)                :: x
    REAL(KIND=dp)                            :: Heaviside

    IF( x < 0.0_dp ) THEN
      Heaviside = 0.0_dp
    ELSE
      Heaviside = 1.0_dp
    END IF
  END FUNCTION Heaviside

END MODULE admm_methods
